---
title: "REMIND-PyPSA-Eur Validation"
author: "Adrian Odenweller, Johannes Hampp"
date: "`r format(Sys.time())`"
output:
  pdf_document:
    number_sections: true
    toc: true
    toc_depth: 3
#    fig_width: 11
#    fig_height: 7.5
    extra_dependencies: ["xcolor"]
fontsize: 11pt
geometry: "a4paper,landscape,left=0.5cm,right=0.5cm,top=0.5cm,bottom=0.5cm,footnotesep=0.0cm,footskip=0.1cm"
documentclass: article
---

\newpage

```{r setup, include=FALSE}
# Load libraries
library(gdx)
library(tidyverse)
library(stringr)
library(quitte)
library(ggpp)
library(ggnewscale)

# Set options for all chunks
knitr::opts_chunk$set(
  dpi = 300,
  echo = FALSE,
  message = FALSE,
  cache = FALSE,
  dev = c("png", "pdf"),
  dev.args = list(png = list(type = "cairo", family = "sans"), pdf = list(family = "sans", bg = "transparent")),
  fig.align = "center",
  fig.width = 11,
  fig.height = 7.5,
  fig.path = "REMIND-PyPSA_Validation_Figures/")

# Set ggplot2 theme
theme_set(theme_bw(base_size = 8))

# Print error and warning messages in red
color_block <- function(color) {
  function(x, options) paste0('\\color{', color, '}\\begin{verbatim}', x, '\\end{verbatim}\\color{black}')
}
knitr::knit_hooks$set(
  warning = color_block('red'),
  error = color_block('red'))

```

# Get REMIND and PyPSA-Eur files

```{r data}
# REMIND directories
rmOutdir <- getwd()
scenario <- basename(rmOutdir)  # Scenario name
# Print REMIND directory
cat("REMIND directory:", rmOutdir, "\n")
# REMIND fulldata_i.gdx files
rmFulldataFiles <- list.files(
  rmOutdir,
  pattern = "fulldata_\\d{1,}.gdx",
  full.names = TRUE)
# REMIND non_optimal_i.gdx files
rmNonOptimalFiles <- list.files(
  rmOutdir,
  pattern = "non_optimal_\\d{1,}.gdx",
  full.names = TRUE)
# REMIND fulldata_i.gdx and non_optimal_i.gdx files
rmFiles <- c(rmFulldataFiles, rmNonOptimalFiles)
# REMIND2PyPSAEUR.gdx files
rm2pyFiles <- list.files(
  rmOutdir,
  pattern = "REMIND2PyPSAEUR_\\d{1,}.gdx",
  full.names = TRUE)
# PyPSAEUR2REMIND.gdx files
py2rmFiles <- list.files(
  rmOutdir,
  pattern = "PyPSAEUR2REMIND_\\d{1,}.gdx",
  full.names = TRUE
)
# Get iterations from rmFiles and sort
rmIterations <- as.numeric(gsub(".*_([0-9]+)\\.gdx", "\\1", rmFiles)) %>%
  sort()

# PyPSA directories
load("config.Rdata")
pyDir <- cfg$gms$c32_pypsa_dir  # Get PyPSA-Eur directory from config.Rdata
# Print PyPSA-Eur directory
cat("PyPSA-Eur directory:", pyDir, "\n")
# PyPSA-Eur resources and results directories
pyResourcesDir <- file.path(pyDir, "resources", scenario)
pyResultsDir <- file.path(pyDir, "results", scenario)
# Get subdirectories labeled "i" for iteration followed by an integer number
pyResultsDirs <- list.dirs(pyResultsDir,
                           recursive = FALSE,
                           full.names = TRUE)
# Get validation subdirectories labeled "validation"
pyValidationDirs <- list.dirs(pyResultsDirs,
                              recursive = FALSE,
                              full.names = TRUE) %>%
  keep(str_detect(., "validation"))
# Get resources subdirectories labeled "i" for iteration and "y" for year
pyResourcesDirs <- list.dirs(pyResourcesDir,
                             recursive = TRUE,
                             full.names = TRUE) %>%
  keep(str_detect(., "y\\d{4}$"))
# Get iteration from PyPSA-Eur validation directories
pyIterations <- as.numeric(gsub(".*i([0-9]+).*", "\\1", pyValidationDirs)) %>%
  sort()

# Some logging
cat("Found", length(rmFulldataFiles), "REMIND fulldata_i.gdx files.\n")
if (length(rmNonOptimalFiles) > 0) {
  warning((paste("Found", length(rmNonOptimalFiles), "REMIND non_optimal_i.gdx files.\n")))
}
cat("Found", length(rm2pyFiles), "REMIND2PyPSAEUR_i.gdx files.\n")
cat("Found", length(pyResultsDirs), "PyPSA-EUR results directories.\n")
cat("Found", length(pyValidationDirs), "PyPSA-EUR validation directories.\n")
cat("Found", length(pyResourcesDirs) / length(years), "PyPSA-EUR resources directories.\n")
cat("Found", length(py2rmFiles), "PyPSAEUR2REMIND_i.gdx files.\n")

# Read coupled years from REMIND
years <- gdx::readGDX(rmFiles[1], "tPy32", restore_zeros = FALSE) %>%
  as.numeric()
# Remove attributes
attr(years, "gdxdata") <- NULL
attr(years, "description") <- NULL

# Read coupled regions from REMIND
regOrder <- c("DEU", "FRA", "EWN")
regions <- gdx::readGDX(rmFiles[1], "regPy32", restore_zeros = FALSE)
# Remove attributes
attr(regions, "gdxdata") <- NULL
attr(regions, "description") <- NULL
# Order regions
regions <- regions[match(regOrder, regions)]
# Remove NAs
regions <- regions[!is.na(regions)]

# Create region list (including all regions as a first entry)
if (length(regions) > 1) {
  regList <- list(
    all_regions = regions
  )
  for (region in regions) {
    regList[[region]] <- region
  }
} else {
  regList <- list(regions)
}

# Unit conversions
twa2twh <- 8760
twa2mwh <- 8760 * 1e6
tC2tCO2 <- 44 / 12
trUSDpTWa2USDpMWh <- 1E12 / twa2mwh
trUSDpTW2USDpMW <- 1E6
```

---
subtitle: "`r scenario`"
---

```{r mappings, include = FALSE}
techMapping <- read.csv(file.path(pyDir, "config", "technology_mapping.csv"))

# Create mapping from REMIND to General
rm2genTech <- setNames(techMapping$general, techMapping$remind.eu)
rm2genTech <- rm2genTech[!duplicated(names(rm2genTech))]

# Create mapping from PyPSA-Eur to General
py2genTech <- setNames(techMapping$general, techMapping$pypsa.eur)
py2genTech <- py2genTech[!duplicated(names(py2genTech))]

# Create mapping from REMIND to PyPSA-Eur (for cost components)
# TODO: Read in from techMapping
rm2pyTech <- c(
  "biochp" = "biomass",
  "bioigcc" = "biomass",
  "bioigccc" = "biomass",
  "ngcc" = "CCGT",
  "ngccc" = "CCGT",
  "gaschp" = "CCGT",
  "igcc" = "coal",
  "igccc" = "coal",
  "pc" = "coal",
  "coalchp" = "coal",
  "tnrs" = "nuclear",
  "fnrs" = "nuclear",
  "ngt" =  "OCGT",
  "windoff" = "offwind",
  "dot" = "oil",
  "wind" = "onwind",
  "hydro" = "hydro",
  "spv" = "solar"
)

# Color mapping
colorsTech <- c(
  "solar_pv" = "#ffcc00",
  "wind_onshore" = "#337fff",
  "wind_offshore" = "#334cff",
  "offwind" = "#334cff",  # Remove later
  "hydro" = "#191999",
  "biomass" = "#005900",
  "CCGT" = "#999959",
  "OCGT" = "#e5e5b2",
  "oil" = "#663a00",
  "all_coal" = "#0c0c0c",
  "coal" = "#0c0c0c",  # Remove later
  "lignite" = "#392306",  # Remove later
  "nuclear" = "#ff33ff"
  )

# Pretty names
namesTech <- c(
  "solar_pv" = "Solar",
  "wind_onshore" = "Wind Onshore",
  "wind_offshore" = "Wind Offshore",
  "offwind" = "Wind Offshore",  # Remove later?
  "hydro" = "Hydro (dams+ror)",
  "biomass" = "Biomass",
  "CCGT" = "CCGT",
  "OCGT" = "OCGT",
  "oil" = "Oil",
  "all_coal" = "Coal+Lignite",
  "coal" = "Coal",  # Remove later?
  "lignite" = "Lignite",  # Remove later?
  "nuclear" = "Nuclear")

# PyPSA-Eur colors (for costs)
pyTechColor <- c(
  "solar" = "#ffcc00",
  "onwind" = "#337fff",
  "offwind" = "#334cff",
  "hydro" = "#191999",
  "biomass" = "#005900",
  "CCGT" = "#999959",
  "OCGT" = "#e5e5b2",
  "oil" = "#663a00",
  "coal" = "#0c0c0c",
  "nuclear" = "#ff33ff"
)

# PyPSA-Eur scaled technologies (for costs)
pyTechScaledColor <- c(
  "solar-rooftop" = "#ffcc00",
  "solar-utility" = "#ffcc00",
  "offwind-ac-connection-submarine" = "#334cff",
  "offwind-ac-connection-underground" = "#334cff",
  "offwind-ac-station" = "#334cff",
  "offwind-dc-connection-submarine" = "#334cff",
  "offwind-dc-connection-underground" = "#334cff",
  "offwind-dc-station" = "#334cff",
  "ror" = "#191999",
  "PHS" = "#191999",
  "lignite" = "#0c0c0c"
)

# PyPSA-Eur scaled shapes (for costs)
pyTechScaledShape <- c(
  "solar-rooftop" = 1,
  "solar-utility" = 2,
  "offwind-ac-connection-submarine" = 3,
  "offwind-ac-connection-underground" = 4,
  "offwind-ac-station" = 5,
  "offwind-dc-connection-submarine" = 6,
  "offwind-dc-connection-underground" = 7,
  "offwind-dc-station" = 8,
  "ror" = 9,
  "PHS" = 10,
  "lignite" = 11
)

```

```{r helpers, include = FALSE}
# This function reads in csv files in the PyPSA-Eur directory
# Expected path: <PyPSA-Eur folder>/i<iteration>/<some file>.csv
# (optionally also containing a y<year> folder)
readPyPSAcsv <- function(paths) {
  purrr::map_df(paths, ~{
    # Extract iteration from path
    iteration <- as.integer(str_extract(.x, "(?<=i)\\d{1,}(?=/)"))
    # Try to extract year from path
    year <- as.integer(str_extract(.x, "(?<=y)\\d{4}"))
    # Try to read csv file
    tryCatch(
      {
        df <- read.csv(.x, header = TRUE) %>%
          as_tibble() %>%
          mutate(iteration = iteration)
        # Conditionally add year column
        if (!("year" %in% names(df)) && !is.na(year)) {
          df <- df %>%
            mutate(year = year)
        }
        df
      },
      error = function(e) {
        cat("Error reading file:", .x, "\n")
        tibble() # Return an empty tibble in case of an error
      }
    )
  })
}

# This function reads in gdx files into tibbles
# rmFile: Path to gdx file
# gdxVar: Name of gdx variable to read
# columns: Named *vector* of columns to select and rename
# colFilter: *List* of renamed columns and values to filter for
readGDXtibble <- function(rmFile, gdxVar, columns, colFilter,
                    restoreZeros = TRUE, field = "l", recalcUnit = 1) {
  # Read gdx file
  data <- gdx::readGDX(rmFile, gdxVar, restore_zeros = restoreZeros, field = field) %>%
    tibble::as_tibble(.name_repair = "unique")
  # If data is empty create tibble with columns from colFilter and column "value" filled with 0
  if (nrow(data) == 0) {
    data <- tibble::tibble(expand.grid(colFilter), value = 0)
  } else {
    data <- data %>%
      # Select desired columns and rename
      dplyr::select_at(names(columns), ~ columns) %>%
      # Filter columns according to colFilter
      dplyr::filter(dplyr::if_all(names(colFilter), ~ . %in% colFilter$.)) %>%
      # Multiply by recalcUnit
      dplyr::mutate(dplyr::across(columns["value"][[1]], ~ . * recalcUnit))
  }
  return(data)
}

# This function reads in multiple gdx files from REMIND
readREMINDgdx <- function(paths, gdxVar, columns, colFilter,
                          restoreZeros = TRUE, field = "l", recalcUnit = 1) {
  purrr::map_df(paths, ~{
    # Extract iteration from path.
    # Files may be named "fulldata_<iteration>.gdx" or
    # "non_optimal_<iteration>.gdx" or "REMIND2PyPSAEUR_<iteration>.gdx"
    iteration <- as.integer(str_extract(.x, "((?<=fulldata_)|(?<=non_optimal_)|(?<=REMIND2PyPSAEUR_))\\d{1,}(?=.gdx)"))
    readGDXtibble(.x, gdxVar, columns, colFilter, restoreZeros, field, recalcUnit) %>%
      mutate(iteration = iteration)
  })
}

# Helper function to extract unique values with a given tolerance
unique_tolerance <- function(x, tolerance = 1e-8) {
  x[!duplicated(round(x / tolerance))]
}

# Helper function to format ggplot subtitles
regSubtitle <- function(r) {
  paste(r, collapse = " + ")
}
```

# Coupled variables

This section includes plots of all variables that are exchanged between REMIND
and PyPSA-Eur.

## REMIND to PyPSA-Eur

This section includes variables that are transferred from REMIND to PyPSA-Eur (displayed as lines).
Values used by PyPSA-EUR are also retrieved to cross-check (displayed as points).

### Electricity load

```{r electricity load}
# Read REMIND data
dataLoadREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "v32_usableSeDisp",
  columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "technology", "value" = "value"),
  colFilter = list("year" = years, "region" = regions, "technology" = "seel"),
  restoreZeros = FALSE,
  recalcUnit = twa2twh)

# Load PyPSAEUR electricity loads for cross-checking
dataLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_loads.csv")) %>%
  mutate(value = value / 1e6)  # Convert MWh to TWh

# Plot by year
pYear <- ggplot() +
  geom_line(data = dataLoadREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataLoadPyPSA, aes(x = year, y = value, color = region)) +
  scale_color_discrete(name = "Region") +
  labs(x = "Year", y = "Electricity load (TWh)") +
  scale_y_continuous(limit = c(0, NA)) +
  ggtitle("Electricity load by year") +
  facet_wrap(~ iteration)

print(pYear)

# Plot by iteration
pIter <- ggplot() +
  geom_line(data = dataLoadREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataLoadPyPSA, aes(x = iteration, y = value, color = region)) +
  scale_color_discrete(name = "Region") +
  labs(x = "Iteration", y = "Electricity load (TWh)") +#
  scale_x_continuous(breaks = rmIterations) +
  scale_y_continuous(limit = c(0, NA)) +
  ggtitle("Electricity load by iteration") +
  facet_wrap(~ year)

print(pIter)
```

### Pre-investment capacities

Pre-investment capacities are used to initialize the PyPSA-Eur model. They are modelled as "free capacity" that PyPSA-Eur can build without incurring any CAPEX.

```{r pre-investment capacities, echo = FALSE, message = FALSE}
# Read REMIND data
dataPreInvCapAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_preInvCapAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_preInvCap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = 1e3) %>%   # TW to GW
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(preInvCap = sum(p32_preInvCap)) %>%
  order.levels(technology = names(colorsTech))

dataPreInvCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_preInvCap",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_preInvCap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = 1e3) %>%   # TW to GW
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(preInvCap = sum(p32_preInvCap)) %>%
  order.levels(technology = names(colorsTech))

# Read PyPSA-Eur data
dataPreInvCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "preinstalled_capacities.csv")) %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  rename(preInvCap = value) %>%
  rename(technology = carrier) %>%
  order.levels(technology = names(colorsTech))

# Loop over regions
for (r in regList){

  dataPreInvCapAvgREMINDplot <- dataPreInvCapAvgREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(preInvCap = sum(preInvCap))

  dataPreInvCapREMINDplot <- dataPreInvCapREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(preInvCap = sum(preInvCap))

  dataPreInvCapPyPSAplot <- dataPreInvCapPyPSA %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(preInvCap = sum(preInvCap))

  pYear <- ggplot() +
    geom_line(data = dataPreInvCapAvgREMINDplot, aes(x = year, y = preInvCap, color = technology)) +
    geom_point(data = dataPreInvCapREMINDplot, aes(x = year, y = preInvCap, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataPreInvCapPyPSAplot, aes(x = year, y = preInvCap, color = technology)) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_shape_manual(name = NULL, values = c("Non-avg. value" = 4)) +
    labs(x = "Year", y = "Capacity (GW)") +
    ggtitle("Pre-investment capacities over years", regSubtitle(r))
  
  print(pYear + facet_wrap(~ iteration))

  pIteration <- ggplot() +
    geom_line(data = dataPreInvCapAvgREMINDplot, aes(x = iteration, y = preInvCap, color = technology)) +
    geom_point(data = dataPreInvCapREMINDplot, aes(x = iteration, y = preInvCap, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataPreInvCapPyPSAplot, aes(x = iteration, y = preInvCap, color = technology)) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_shape_manual(name = NULL, values = c("Non-avg. value" = 4)) +
    labs(x = "Iteration", y = "Capacity (GW)") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Pre-investment capacities over iterations", regSubtitle(r))

  print(pIteration + facet_wrap(~ year))

  print(pYear +
    facet_grid(technology ~ iteration,
               scales = "free",
               labeller = labeller(technology = namesTech)) +
    theme(legend.position = "none"))
  
  print(pIteration +
    facet_grid(technology ~ year,
               scales = "free",
               labeller = labeller(technology = namesTech)) +
    theme(legend.position = "none"))
}
```

### Specific capital costs (investment costs), including adjustment costs

Costs are the same across all regions as PyPSA-Eur doesn't have regionalised costs (yet). Costs from REMIND are hence aggregated.

```{r specific capital costs}
# REMIND
dataCapexREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_capCostwAdjCost",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_capCostwAdjCost"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = trUSDpTW2USDpMW)

dataGenTechREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

dataCapexWeightedREMIND <- dataCapexREMIND %>%
  left_join(dataGenTechREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(capex = sum(p32_capCostwAdjCost * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(pyTechColor))

# PyPSA-Eur
dataCapexPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "investment",
         source == "REMIND-EU")

# Filter if further.description starts with "Extracted from REMIND-EU"
dataCapexPyPSAextracted <- dataCapexPyPSA %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  order.levels(technology = names(pyTechColor))

# Filter if further.description starts with "Scaled value from REMIND-EU"
dataCapexPyPSAscaled <- dataCapexPyPSA %>%
  filter(str_detect(further.description, "^Scaled value from REMIND-EU")) %>%
  order.levels(technology = names(pyTechScaledColor))

pCapexYear <- ggplot() +
  geom_line(data = dataCapexWeightedREMIND, aes(x = year, y = capex, color = technology)) +
  geom_point(data = dataCapexPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataCapexPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "Specific capital costs (USD/kW)") +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Specific capital costs (w/ adjustment costs) over years") +
  facet_wrap(~ iteration)

print(pCapexYear)

pCapexIter <- ggplot() +
  geom_line(data = dataCapexWeightedREMIND, aes(x = iteration, y = capex, color = technology)) +
  geom_point(data = dataCapexPyPSAextracted, aes(x = iteration, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataCapexPyPSAscaled, aes(x = iteration, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Iteration", y = "Specific capital costs (USD/kW)") +
  scale_x_continuous(breaks = rmIterations) +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Specific capital costs (w/ adjustment costs) over iterations") +
  facet_wrap(~ year)

print(pCapexIter)

pCapexTechExtractedYear <- ggplot() +
  geom_line(data = dataCapexWeightedREMIND, aes(x = year, y = capex, color = technology)) +
  geom_point(data = dataCapexPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  labs(x = "Year", y = "Specific capital costs (USD/kW)") +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Specific capital costs (w/ adjustment costs) over years, technologies directly from REMIND") +
  facet_grid(technology ~ iteration, scales = "free") +
  theme(legend.position = "none")

print(pCapexTechExtractedYear)

pCapexTechScaledYear <- ggplot() +
  geom_point(data = dataCapexPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology)) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "Specific capital costs (USD/kW)") +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Specific capital costs (w/ adjustment costs) over years, additional scaled PyPSA-Eur technologies") +
  facet_grid(technology ~ iteration, scales = "free", labeller = label_wrap_gen(multi_line = TRUE)) +
  theme(legend.position = "none")

print(pCapexTechScaledYear)
```

#### CAPEX and adjustment costs in REMIND

```{r capex and adjustment costs}

dataCapexTotREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_capCostwAdjCost",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_capCostwAdjCost"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = trUSDpTW2USDpMW)

dataCAPEXonlyREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_costTeCapital",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_costTeCapital"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = trUSDpTW2USDpMW)

dataCapexPlotREMIND <- dataCapexTotREMIND %>%
  left_join(dataCAPEXonlyREMIND, by = c("year", "region", "technology", "iteration")) %>%
  group_by(year, technology, iteration) %>%
  mutate(adjustment = p32_capCostwAdjCost - vm_costTeCapital) %>%
  # Use pivot_longer on adjustment and vm_costTeCapital
  tidyr::pivot_longer(cols = c("adjustment", "vm_costTeCapital"),
                      names_to = "char",
                      values_to = "value")

p <- ggplot() +
  geom_bar(data = dataCapexPlotREMIND,
           aes(x = year, y = value, fill = char),
           stat = "identity") +
  scale_fill_discrete(name = NULL,
                      labels = c("adjustment" = "Adjustment costs",
                                  "vm_costTeCapital" = "Capital costs")) +
  labs(x = "Year", y = "Specific capital costs (USD/kW)") +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Specific capital costs and adjustment costs over years") +
  facet_grid(technology ~ iteration, scales = "free")

print(p)

```

### Fixed O&M costs

```{r fixed o&m costs}
# REMIND
dataFOMREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "variable", "all_te" = "technology", "value" = "value"),
    colFilter = list("region" = regions, "variable" = "omf", "technology" = names(rm2genTech))) %>%
  mutate(value = 100 * value) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(variable, technology) %>%
  # Values should be the same across years and iterations
  summarise(value = unique(value)) %>%
  # Add column for year
  tidyr::crossing(year = years) %>%
  order.levels(technology = names(pyTechColor))

# PyPSA-Eur
dataFOMPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "FOM",
         source == "REMIND-EU") %>%
  group_by(technology, parameter, further.description, year) %>%
  # Values should be the same across iterations
  summarise(value = unique_tolerance(value))

# Filter if further.description starts with "Extracted from REMIND-EU"
# Values in this tibble should be the same across years
dataFOMPyPSAextracted <- dataFOMPyPSA %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  order.levels(technology = names(pyTechColor))

# Filter if further.description starts with "Scaled value from REMIND-EU"
# Values in this tibble might vary across years
dataFOMPyPSAscaled <- dataFOMPyPSA %>%
  filter(str_detect(further.description, "^Scaled value from REMIND-EU")) %>%
  order.levels(technology = names(pyTechScaledColor))

pFOMYear <- ggplot() +
  geom_line(data = dataFOMREMIND, aes(x = year, y = value, color = technology)) +
  geom_point(data = dataFOMPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataFOMPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology)) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "Fixed O&M costs (%)") +
  ggtitle("Fixed O&M costs over years") +
  facet_wrap(~ technology)

print(pFOMYear)
```

### Lifetimes

```{r lifetimes}
dataLifetimesREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "variable", "all_te" = "technology", "value" = "value"),
    colFilter = list("region" = regions, "variable" = "lifetime", "technology" = names(rm2genTech))) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(variable, technology) %>%
  # Values should be the same across years and iterations
  summarise(value = unique(value)) %>%
  # Add column for year
  tidyr::crossing(year = years) %>%
  order.levels(technology = names(pyTechColor))

dataLifetimesPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "lifetime",
         source == "REMIND-EU") %>%
  group_by(technology, parameter, further.description, year) %>%
  # Check for uniqueness with a given tolerance across iterations
  summarise(value = unique_tolerance(value))

dataLifetimesPyPSAextracted <- dataLifetimesPyPSA %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  order.levels(technology = names(pyTechColor))

dataLifetimesPyPSAscaled <- dataLifetimesPyPSA %>%
  filter(str_detect(further.description, "^Scaled value from REMIND-EU")) %>%
  order.levels(technology = names(pyTechScaledColor))

pLifetimes <- ggplot() +
  geom_line(data = dataLifetimesREMIND, aes(x = year, y = value, color = technology)) +
  geom_point(data = dataLifetimesPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataLifetimesPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology)) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "Lifetime (years)") +
  ggtitle("Lifetimes over years") +
  facet_wrap(~ technology)

print(pLifetimes)
```

### Discount rates

ToDo

```{r discount rates}

#TODO: Change to p32_discountRate

```

### Variable O&M costs

```{r variable o&m costs}

dataVOMREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "variable", "all_te" = "technology", "value" = "vom"),
    colFilter = list("region" = regions, "variable" = "omv", "technology" = names(rm2genTech)),
    recalcUnit = trUSDpTWa2USDpMWh) %>%
    group_by(region, variable, technology) %>%
  # Remove if all values are 0
  filter(!all(vom == 0))

dataGenTechREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

dataVOMWeightedREMIND <- dataVOMREMIND %>%
  left_join(dataGenTechREMIND, by = c("region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(vom = sum(vom * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(pyTechColor))

dataVOMPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "VOM",
         source == "REMIND-EU")

# Filter if further.description starts with "Extracted from REMIND-EU"
dataVOMPyPSAextracted <- dataVOMPyPSA %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  order.levels(technology = names(pyTechColor))

# Filter if further.description starts with "Scaled value from REMIND-EU"
dataVOMPyPSAscaled <- dataVOMPyPSA %>%
  filter(str_detect(further.description, "^Scaled value from REMIND-EU")) %>%
  order.levels(technology = names(pyTechScaledColor))

pVOMYear <- ggplot() +
  geom_line(data = dataVOMWeightedREMIND, aes(x = year, y = vom, color = technology)) +
  geom_point(data = dataVOMPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataVOMPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology)) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "Variable O&M costs (USD/MWh)") +
  ggtitle("Variable O&M costs over years") +
  facet_grid(technology ~ iteration, scales = "free") +
  theme(legend.position = "none")

print(pVOMYear)

pVOMIter <- ggplot() +
  geom_line(data = dataVOMWeightedREMIND, aes(x = iteration, y = vom, color = technology)) +
  geom_point(data = dataVOMPyPSAextracted, aes(x = iteration, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataVOMPyPSAscaled, aes(x = iteration, y = value, color = technology, shape = technology)) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Iteration", y = "Variable O&M costs (USD/MWh)") +
  scale_x_continuous(breaks = rmIterations) +
  ggtitle("Variable O&M costs over iterations") +
  facet_grid(technology ~ year, scales = "free") +
  theme(legend.position = "none")

print(pVOMIter)

```

### Efficiencies

```{r efficiencies}
# Technologies for which eta is constant
dataEtaConvREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_eta_conv",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2pyTech)))

# Technologies for which eta varies over time
dataEtaTimeREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataeta",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2pyTech)))

# Read weights
dataGenTechREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

# Weighted efficiencies
dataEtaWeightedREMIND <- dataEtaConvREMIND %>%
  bind_rows(dataEtaTimeREMIND) %>%
  # Special treament for nuclear: Set efficiency to 1 as this is already included in the fuel costs
  mutate(eta = if_else(technology %in% c("tnrs", "fnrs"), 1, eta)) %>%
  left_join(dataGenTechREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(eta = sum(eta * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(pyTechColor))

# Read PyPSA-Eur data
dataEtaPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "efficiency",
         source == "REMIND-EU")

# Filter if further.description starts with "Extracted from REMIND-EU"
dataEtaPyPSAextracted <- dataEtaPyPSA %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  order.levels(technology = names(pyTechColor))

# Filter if further.description starts with "Scaled value from REMIND-EU"
dataEtaPyPSAscaled <- dataEtaPyPSA %>%
  filter(str_detect(further.description, "^Scaled value from REMIND-EU")) %>%
  order.levels(technology = names(pyTechScaledColor))

pEtaYear <- ggplot() +
  geom_line(data = dataEtaWeightedREMIND, aes(x = year, y = eta, color = technology)) +
  geom_point(data = dataEtaPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataEtaPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "Efficiency") +
  ggtitle("Efficiencies over years") +
  facet_grid(technology ~ iteration) +
  theme(legend.position = "none")

print(pEtaYear)

pEtaIter <- ggplot() +
  geom_line(data = dataEtaWeightedREMIND, aes(x = iteration, y = eta, color = technology)) +
  geom_point(data = dataEtaPyPSAextracted, aes(x = iteration, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataEtaPyPSAscaled, aes(x = iteration, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Iteration", y = "Efficiency") +
  scale_x_continuous(breaks = rmIterations) +
  ggtitle("Efficiencies over iterations") +
  facet_grid(technology ~ year) +
  theme(legend.position = "none")

print(pEtaIter)
```

### Fuel costs

```{r fuel costs}

# Read pe2se mapping from REMIND
pe2seTech <- gdx::readGDX(rmFiles[1], "pe2se") %>%
  rename(pecarrier = all_enty,
         secarrier = all_enty1,
         technology = all_te) %>%
  filter(secarrier == "seel") %>%
  select(pecarrier, technology)

# Read REMIND data (averaged)
dataFuelCostsAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PEPriceAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "pecarrier", "value" = "p32_PEPriceAvg"),
    colFilter = list("year" = years, "region" = regions)) %>%
  full_join(pe2seTech, by = c("pecarrier"), relationship = "many-to-many") %>%
  full_join(dataEtaConvREMIND) %>%
  # Special treatment for nuclear: Costs in T$/Mt uranium, efficiency in TWa/Mt uranium
  mutate(p32_PEPriceAvg = case_when(pecarrier == "peur" ~ p32_PEPriceAvg / eta * trUSDpTWa2USDpMWh,
                                pecarrier != "peur" ~ p32_PEPriceAvg * trUSDpTWa2USDpMWh))

# Read REMIND data (true costs)
dataFuelCostsREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_PEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "pecarrier", "value" = "pm_PEPrice"),
    colFilter = list("year" = years, "region" = regions)) %>%
  full_join(pe2seTech, by = c("pecarrier"), relationship = "many-to-many") %>%
  full_join(dataEtaConvREMIND) %>%
  # Special treatment for nuclear: Costs in T$/Mt uranium, efficiency in TWa/Mt uranium
  mutate(pm_PEPrice = case_when(pecarrier == "peur" ~ pm_PEPrice / eta * trUSDpTWa2USDpMWh,
                                pecarrier != "peur" ~ pm_PEPrice * trUSDpTWa2USDpMWh)
)

# Read weights
dataGenTechREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

# Calculate weighted average fuel costs
dataFuelCostsAvgWeightedREMIND <- dataFuelCostsAvgREMIND %>%
  right_join(dataGenTechREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(fuelCost = sum(p32_PEPriceAvg * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(pyTechColor))

# Calculate true average fuel costs
dataFuelCostsWeightedREMIND <- dataFuelCostsREMIND %>%
  right_join(dataGenTechREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(fuelCost = sum(pm_PEPrice * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(pyTechColor))

# Read PyPSA-Eur data
dataFuelCostsPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "fuel",
         source == "REMIND-EU")

# Filter if further.description starts with "Extracted from REMIND-EU"
dataFuelCostsPyPSAextracted <- dataFuelCostsPyPSA %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  order.levels(technology = names(pyTechColor))

# Filter if further.description starts with "Scaled value from REMIND-EU"
dataFuelCostsPyPSAscaled <- dataFuelCostsPyPSA %>%
  filter(str_detect(further.description, "^Scaled value from REMIND-EU")) %>%
  order.levels(technology = names(pyTechScaledColor))

# Remove technologies with zero fuel costs in both REMIND and PyPSA-Eur
techFuelCostsZero <- left_join(dataFuelCostsAvgWeightedREMIND, dataFuelCostsPyPSAextracted) %>%
  group_by(technology) %>%
  filter(all(fuelCost == 0) & all(value == 0)) %>%
  pull(technology) %>%
  unique()

dataFuelCostsAvgWeightedREMIND <- dataFuelCostsAvgWeightedREMIND %>%
  filter(!technology %in% techFuelCostsZero)

dataFuelCostsPyPSAextracted <- dataFuelCostsPyPSAextracted %>%
  filter(!technology %in% techFuelCostsZero)

dataFuelCostsWeightedREMIND <- dataFuelCostsWeightedREMIND %>%
  filter(!technology %in% techFuelCostsZero)

pFuelCostsYear <- ggplot() +
  geom_line(data = dataFuelCostsAvgWeightedREMIND, aes(x = year, y = fuelCost, color = technology)) +
  geom_point(data = dataFuelCostsWeightedREMIND, aes(x = year, y = fuelCost, color = technology, shape = "True costs")) +
  scale_shape_manual(name = NULL,
                     values = c("True costs" = 4)) +
  geom_point(data = dataFuelCostsPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  new_scale("shape") +
  geom_point(data = dataFuelCostsPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "Fuel costs (USD/MWh)") +
  ggtitle("Fuel costs over years", "Averaged over iterations")

print(pFuelCostsYear + facet_wrap(~ iteration))

pFuelCostsIter <- ggplot() +
  geom_line(data = dataFuelCostsAvgWeightedREMIND, aes(x = iteration, y = fuelCost, color = technology)) +
  geom_point(data = dataFuelCostsWeightedREMIND, aes(x = iteration, y = fuelCost, color = technology, shape = "True costs")) +
  scale_shape_manual(name = NULL,
                     values = c("True costs" = 4)) +
  geom_point(data = dataFuelCostsPyPSAextracted, aes(x = iteration, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  new_scale("shape") +
  geom_point(data = dataFuelCostsPyPSAscaled, aes(x = iteration, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Iteration", y = "Fuel costs (USD/MWh)") +
  scale_x_continuous(breaks = rmIterations) +
  ggtitle("Fuel costs over iterations", "Averaged over iterations")

print(pFuelCostsIter + facet_wrap(~ year))

print(pFuelCostsYear +
  facet_grid(technology ~ iteration,
              scales = "free",
              labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none"))

print(pFuelCostsIter +
  facet_grid(technology ~ year,
              scales = "free",
              labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none"))

```

### CO2 intensity

```{r co2 intensity}

# Read REMIND data
dataCO2intREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "fm_dataemiglob",
    columns = c("all_enty" = "pecarrier", "all_enty1" = "secarrier", "all_te" = "technology", "all_enty2" = "gas", "value" = "co2int"),
    colFilter = list("secarrier" = "seel", "gas" = "co2", technology = names(rm2pyTech)),
    restoreZeros = FALSE,
    recalcUnit = 1E9 * tC2tCO2 / twa2mwh) %>%
  group_by(technology) %>%
  summarise(co2int = unique(co2int))

# Read weights
dataGenTechREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

dataCO2intWeightedREMIND <- dataCO2intREMIND %>%
  right_join(dataGenTechREMIND, by = c("technology")) %>%
  group_by(technology) %>%
  filter(!is.na(co2int)) %>%
  revalue.levels(technology = rm2pyTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(co2int = sum(co2int * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(pyTechColor))

dataCO2intPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "CO2 intensity",
         source == "REMIND-EU")

# Filter if further.description starts with "Extracted from REMIND-EU"
dataCO2intPyPSAextracted <- dataCO2intPyPSA %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  order.levels(technology = names(pyTechColor))

# Filter if further.description starts with "Scaled value from REMIND-EU"
dataCO2intPyPSAscaled <- dataCO2intPyPSA %>%
  filter(str_detect(further.description, "^Scaled value from REMIND-EU")) %>%
  order.levels(technology = names(pyTechScaledColor))

pCO2intYear <- ggplot() +
  geom_line(data = dataCO2intWeightedREMIND, aes(x = year, y = co2int, color = technology)) +
  geom_point(data = dataCO2intPyPSAextracted, aes(x = year, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataCO2intPyPSAscaled, aes(x = year, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Year", y = "CO2 intensity (tCO2/MWh)") +
  ggtitle("CO2 intensity over years") +
  facet_grid(technology ~ iteration) +
  theme(legend.position = "none")

print(pCO2intYear)

pCO2intIter <- ggplot() +
  geom_line(data = dataCO2intWeightedREMIND, aes(x = iteration, y = co2int, color = technology)) +
  geom_point(data = dataCO2intPyPSAextracted, aes(x = iteration, y = value, color = technology)) +
  scale_color_manual(name = "Extracted technology\n(directly from REMIND)",
                     values = pyTechColor,
                     guide = guide_legend(order = 1)) +
  new_scale_color() +
  geom_point(data = dataCO2intPyPSAscaled, aes(x = iteration, y = value, color = technology, shape = technology),
             alpha = 0.5) +
  scale_color_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledColor,
                     guide = guide_legend(order = 2)) +
  scale_shape_manual(name = "Scaled technology\n(similar REMIND tech)",
                     values = pyTechScaledShape,
                     guide = guide_legend(order = 2)) +
  labs(x = "Iteration", y = "CO2 intensity (tCO2/MWh)") +
  scale_x_continuous(breaks = rmIterations) +
  ggtitle("CO2 intensity over iterations") +
  facet_grid(technology ~ year) +
  theme(legend.position = "none")

print(pCO2intIter)

```

### CO2 prices

TODO: How to aggregate CO2 prices?

```{r co2 price}
# REMIND data
dataCO2PriceREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "p_priceCO2",
  columns = c("tall" = "year", "all_regi" = "region", "value" = "value"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = TRUE,
  recalcUnit = 1 / tC2tCO2
)

# PyPSA data
dataCO2PricePyPSA <- readPyPSAcsv(
    paths = file.path(pyResultsDirs, "co2_price_scenarios.csv")) %>% 
  # Extract the CO2 price from the opts columns which starts with Ep followed by a number of format 0.0
  mutate(value = as.numeric(str_extract(opts, "(?<=Ep)\\d+\\.\\d{1,2}")))

# Plot by year
pCO2PriceYear <- ggplot() +
  geom_line(data = dataCO2PriceREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataCO2PricePyPSA, aes(x = year, y = value, color = "All regions")) +  # TODO
  labs(x = "Year", y = "CO2 price (USD/tCO2)") +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("CO2 price over years") +
  facet_wrap(~ iteration)

print(pCO2PriceYear)

# Plot by iteration
pCO2PriceIter <- ggplot() +
  geom_line(data = dataCO2PriceREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataCO2PricePyPSA, aes(x = iteration, y = value, color = "All regions")) +  # TODO
  labs(x = "Iteration", y = "CO2 price (USD/tCO2)") +
  scale_x_continuous(breaks = rmIterations) +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("CO2 price over iterations") +
  facet_wrap(~ year)

print(pCO2PriceIter)
```

## PyPSA-Eur to REMIND

This section includes variables that are transferred from PyPSA-Eur to REMIND (displayed as points).
Values used by REMIND are also retrieved to cross-check (displayed as lines).

### Capacity factors

The following plots show the capacity factor.

ToDo: This doesn't work properly for the case of "all regions" yet as the PyPSA capacity factors cannot simply be aggregated over regions.

```{r capacity factors}
# REMIND capacity factors (pre-factor based)
dataCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_cap",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
    restoreZeros = FALSE) %>%
  select(-grade)

dataUsableSeTeDispREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

dataPHScapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_iniCapPHS",
    columns = c("all_regi" = "region", "all_te" = "technology", "value" = "p32_iniCapPHS"),
    colFilter = list("region" = regions),
    restoreZeros = TRUE)

# REMIND averaged capacity factors
dataCapFacAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PyPSA_CFAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PyPSA_CFAvg"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  # Increment iteration by 1 because this value is only available for the next iteration
  mutate(iteration = iteration + 1) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(p32_PyPSA_CFAvg = unique(p32_PyPSA_CFAvg))

# PyPSA-Eur capacity factors
dataCapfacPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "capacity_factors.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value))

for (r in regList){

  dataCapfacREMINDplot <- full_join(dataCapREMIND, dataPHScapREMIND) %>%
    full_join(dataUsableSeTeDispREMIND) %>%
    filter(region %in% r,
           vm_cap != 0) %>%
    group_by(year, technology, iteration) %>%
    # First calculate capacity factor for each REMIND technology across all regions
    summarise(capfac = sum(v32_usableSeTeDisp) / sum(vm_cap - p32_iniCapPHS),
              v32_usableSeTeDispRegSum = sum(v32_usableSeTeDisp)) %>%
    revalue.levels(technology = rm2genTech) %>%
    group_by(year, technology, iteration) %>%
    # Second calculate weighted capacity factor for general technologies
    summarise(capfac = sum(capfac * v32_usableSeTeDispRegSum) / sum(v32_usableSeTeDispRegSum)) %>%
    quitte::order.levels(technology = names(namesTech)) %>%
    rename(value = capfac)

  dataCapfacPyPSAplot <- dataCapfacPyPSA %>%
    filter(region %in% r,
           value != 0) %>%
    group_by(year, carrier, iteration) %>%
    rename(technology = carrier) %>%
    summarise(value = mean(value)) %>%  # ToDO: This is not exactly correct for all regions
    quitte::order.levels(technology = names(namesTech))

  # Plot by year
  pCapfacYear <- ggplot() +
    geom_line(data = dataCapfacREMINDplot, aes(x = year, y = value, color = technology)) +
    geom_point(data = dataCapfacPyPSAplot, aes(x = year, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataCapFacAvgREMIND, aes(x = year, y = p32_PyPSA_CFAvg, color = technology)) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Capacity factor") +
    ggtitle("Capacity factors over years, averaged over iterations", regSubtitle(r))

  print(pCapfacYear + facet_wrap(~ iteration))

  # Plot by iteration
  pCapfacIter <- ggplot() +
    geom_line(data = dataCapfacREMINDplot, aes(x = iteration, y = value, color = technology)) +
    geom_point(data = dataCapfacPyPSAplot, aes(x = iteration, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataCapFacAvgREMIND, aes(x = iteration, y = p32_PyPSA_CFAvg, color = technology)) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Iteration", y = "Capacity factor") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Capacity factors over iterations, averaged over iterations", regSubtitle(r))

  print(pCapfacIter + facet_wrap(~ year))

  print(pCapfacYear + facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))
  
  print(pCapfacIter + facet_grid(technology ~ year, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))

}
```

### Curtailments

Work in progress. Not yet coupled from PyPSA-Eur to REMIND.

```{r curtailments}
# REMIND
tePyVRE32 <- gdx::readGDX(rmFiles[1], "tePyVRE32", restore_zeros = FALSE)

dataCurtailmentREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_storloss",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "v32_storloss"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  filter(technology %in% tePyVRE32) %>%
  revalue.levels(technology = rm2genTech) %>%
  quitte::order.levels(technology = names(colorsTech))


# PyPSA-Eur
dataCurtailmentPyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "curtailments.csv")) %>%
  filter(value != 0) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  quitte::order.levels(carrier = names(namesTech)) %>%
  mutate(value = value / 1e6) %>%  # Convert MWh to TWh
  rename(technology = carrier)

for (r in regList) {

  dataCurtailmentplotREMIND <- dataCurtailmentREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(v32_storloss = sum(v32_storloss))

  dataCurtailmentplotPyPSA <- dataCurtailmentPyPSA %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(value = sum(value))

  pCurtailmentYear <- ggplot() +
    geom_line(data = dataCurtailmentplotREMIND, aes(x = year, y = v32_storloss, color = technology)) +
    geom_point(data = dataCurtailmentplotPyPSA, aes(x = year, y = value, color = technology)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Curtailment (TWh/yr)") +
    ggtitle("Curtailment over years", regSubtitle(r)) +
    facet_wrap(~ iteration)

  print(pCurtailmentYear)

  pCurtailmentIter <- ggplot() +
    geom_line(data = dataCurtailmentplotREMIND, aes(x = iteration, y = v32_storloss, color = technology)) +
    geom_point(data = dataCurtailmentplotPyPSA, aes(x = iteration, y = value, color = technology)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Curtailment (TWh/yr)") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Curtailment over iterations", regSubtitle(r)) +
    facet_wrap(~ year)

  print(pCurtailmentIter)
}
```

### Markups

Markups and markdowns are read into REMIND from PYPSA-Eur. Markup = Average market value - Average electricity price

ToDO: Aggregation is not correct yet.

```{r markup}
# REMIND (pre-factor based)
dataMarkupREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_PyPSAMarkup",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh)

dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  select(-secarrier)

dataMarkupWeightedREMIND <- dataMarkupREMIND %>%
  right_join(dataGenREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(namesTech))

# PyPSA-Eur
dataMarketValuePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "market_values.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  quitte::order.levels(carrier = names(namesTech))

dataElecPricePYPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_prices.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1)

dataMarkupPyPSA <- dataMarketValuePyPSA %>%
  left_join(dataElecPricePYPSA, by = c("year", "region", "iteration")) %>%
  mutate(value = value.x - value.y) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  rename(technology = carrier) %>%
  order.levels(technology = names(namesTech))

# Average markup REMIND
dataMarketValueAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PyPSA_MVAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PyPSA_MVAvg"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  # Increment iteration by 1 because this value is only available for the next iteration
  mutate(iteration = iteration + 1) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(p32_PyPSA_MVAvg = unique(p32_PyPSA_MVAvg))

dataMarkupAvgREMIND <- dataMarketValueAvgREMIND %>%
  right_join(dataElecPricePYPSA, by = c("year", "region", "iteration")) %>%
  mutate(p32_PyPSA_MarkupAvg = p32_PyPSA_MVAvg - value)

for (r in regList) {

  dataMarkupPlotREMIND <- dataMarkupWeightedREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(value = mean(value))  # ToDo: Incorrect aggregation

  dataMarkupPlotPyPSA <- dataMarkupPyPSA %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(value = mean(value))  # ToDo: Incorrect aggregation

  pMarkupYear <- ggplot() +
    geom_line(data = dataMarkupPlotREMIND, aes(x = year, y = value, color = technology)) +
    geom_point(data = dataMarkupPlotPyPSA, aes(x = year, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataMarkupAvgREMIND, aes(x = year, y = p32_PyPSA_MarkupAvg, color = technology)) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Markup ($/MWh)") +
    ggtitle("Markups over years", regSubtitle(r))

  print(pMarkupYear + facet_wrap(~ iteration, scales = "free"))

  pMarkUpIter <- ggplot() +
    geom_line(data = dataMarkupPlotREMIND, aes(x = iteration, y = value, color = technology)) +
    geom_point(data = dataMarkupPlotPyPSA, aes(x = iteration, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataMarkupAvgREMIND, aes(x = iteration, y = p32_PyPSA_MarkupAvg, color = technology)) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Iteration", y = "Markup ($/MWh)") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Markups over iterations", regSubtitle(r))

  print(pMarkUpIter + facet_wrap(~ year, scales = "free"))

  print(pMarkupYear +
        facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))

  print(pMarkUpIter +
        facet_grid(technology ~ year, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))
}
```

### Markup tax revenue

Markups are implemented as a tax/subsidy in REMIND in order to manipulate a variable that is usually an outcome (Lagrangian multiplier of the optimisation) and not an input.

Here we look at the tax revenue from markups, which should approach zero over iterations.

```{r markup tax revenue}
# REMIND
dataMarkUpRevenue <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v21_taxrevPyPSAMarkup",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE,
    recalcUnit = -1E6)  # T$/yr to Million $/yr

for (r in regList) {
  
  dataMarkUpRevenuePlot <- dataMarkUpRevenue %>%
    filter(region %in% r) %>%
    group_by(year, iteration) %>%
    summarise(value = sum(value))

  pMarkUpRevenue <- ggplot() +
    geom_line(data = dataMarkUpRevenuePlot, aes(x = year, y = value)) +
    labs(x = "Year", y = "Markup revenue (Million $/yr)") +
    ggtitle("Markup revenue over years", regSubtitle(r)) +
    facet_wrap(~ iteration)

  print(pMarkUpRevenue)
}
```

### Peak residual load

Relative peak residual load is passed from PyPSA-Eur to REMIND. REMIND can go higher than the PyPSA-Eur value, but not lower.

```{r peak residual load relative}
# REMIND data (pre-factor based)
dataCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_cap",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
    restoreZeros = FALSE)

tePyDisp32 <- gdx::readGDX(rmFiles[1], "tePyDisp32", restore_zeros = FALSE)

dataDispCapSumREMIND <- dataCapREMIND %>%
  filter(technology %in% tePyDisp32) %>%
  group_by(year, region, iteration) %>%
  summarise(dispCapSum = sum(vm_cap))

dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "v32_usableSeDisp"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE)

dataPeakResLoadREMIND <- dataDispCapSumREMIND %>%
  left_join(dataGenREMIND, by = c("year", "region", "iteration")) %>%
  mutate(peakResLoad = dispCapSum / v32_usableSeDisp)

# PyPSA csv contains both absolute and relative
dataPeakResLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "peak_residual_loads.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1)

pPeakResLoadYear <- ggplot() +
  geom_line(data = dataPeakResLoadREMIND, aes(x = year, y = peakResLoad, color = region)) +
  geom_point(data = dataPeakResLoadPyPSA, aes(x = year, y = relative, color = region)) +
  labs(x = "Year", y = "Relative peak residual load") +
  ggtitle("Relative peak residual load over years") +
  facet_wrap(~ iteration)

print(pPeakResLoadYear)

pPeakResLoadIter <- ggplot() +
  geom_line(data = dataPeakResLoadREMIND, aes(x = iteration, y = peakResLoad, color = region)) +
  geom_point(data = dataPeakResLoadPyPSA, aes(x = iteration, y = relative, color = region)) +
  labs(x = "Iteration", y = "Relative peak residual load") +
  scale_x_continuous(breaks = rmIterations) +
  ggtitle("Relative peak residual load over iterations") +
  facet_wrap(~ year)

print(pPeakResLoadIter)

```

```{r peak residual load absolute}

pPeakResLoadAbsYear <- ggplot() +
  geom_line(data = dataPeakResLoadPyPSA, aes(x = year, y = absolute, color = region)) +
  labs(x = "Year", y = "Peak residual load (GW)") +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Peak residual load over years in PyPSA-Eur", "Not directly coupled with REMIND") +
  facet_wrap(~ iteration)

print(pPeakResLoadAbsYear)

```

### Electricity trade

ToDo.

# Convergence indicators

This section includes variables that are not exchanged directly between REMIND and PyPSA-Eur, but that should converge.

## Capacities

### Optimal capacities in REMIND

```{r optimal capacities in REMIND}
dataCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_cap",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
    restoreZeros = FALSE,
    recalcUnit = 1e3) %>%   # TW to GW
  select(-grade)  # Remove grade column

dataPHScapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_iniCapPHS",
    columns = c("all_regi" = "region", "all_te" = "technology", "value" = "p32_iniCapPHS"),
    colFilter = list("region" = regions),
    restoreZeros = TRUE,
    recalcUnit = 1e3)  # TW to GW

for (r in regList) {

  dataCapREMINDplot <- left_join(dataCapREMIND, dataPHScapREMIND) %>%
    mutate(cap = vm_cap - p32_iniCapPHS) %>%
    filter(region %in% r) %>%
    revalue.levels(technology = rm2genTech) %>%
    group_by(year, technology, iteration) %>%
    summarise(cap = sum(cap)) %>%
    order.levels(technology = names(colorsTech))

  pYear <- ggplot() +
    geom_line(data = dataCapREMINDplot, aes(x = year, y = cap, color = technology)) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    labs(x = "Year", y = "Capacity (GW)") +
    ggtitle("Optimal capacities in REMIND over years", regSubtitle(r))
  
  print(pYear + facet_wrap(~ iteration))

  pIter <- ggplot() +
    geom_line(data = dataCapREMINDplot, aes(x = iteration, y = cap, color = technology)) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    labs(x = "Iteration", y = "Capacity (GW)") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Optimal capacities in REMIND over iterations", regSubtitle(r))

  print(pIter + facet_wrap(~ year, scales = "free"))

  print(pYear + facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech)) +
          theme(legend.position = "none"))

  print(pIter + facet_grid(technology ~ year, scales = "free", labeller = labeller(technology = namesTech)) +
          theme(legend.position = "none"))
}
```

### Pre-investment capacities and capacity expansion over years

The following plots contain the pre-investment capacities and each model's capacity expansion decision.
Pre-investment capacities are determined in REMIND and passed to PyPSA-Eur as "free capacity", i.e. capacity for which PyPSA-Eur does not have to pay any CAPEX.
PyPSA-Eur should therefore only start investing into new capacity once the free pre-investment capacity has been fully used. PyPSA-Eur does not have to use all of the pre-investment capacity.

```{r capacity expansion over years}

# Read REMIND data
dataPreInvCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_preInvCap",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_preInvCap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = 1e3)

dataPHScapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_iniCapPHS",
    columns = c("all_regi" = "region", "all_te" = "technology", "value" = "p32_iniCapPHS"),
    colFilter = list("region" = regions),
    restoreZeros = TRUE,
    recalcUnit = 1e3)  # TW to GW

dataCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_cap",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
    restoreZeros = FALSE,
    recalcUnit = 1e3) %>%   # TW to GW
  select(-grade)  # Remove grade column

dataCapInvestREMIND <- left_join(dataPreInvCapREMIND, dataPHScapREMIND) %>%
  full_join(dataCapREMIND) %>%
  mutate(vm_cap = vm_cap - p32_iniCapPHS,
         deltaCap = vm_cap - p32_preInvCap) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(deltaCap = sum(deltaCap),
            preInvCap = sum(p32_preInvCap)) %>%
  order.levels(technology = names(colorsTech)) %>%
  pivot_longer(cols = c("deltaCap", "preInvCap"),
               names_to = "variable",
               values_to = "value")

# Read PyPSA-Eur data
dataPreInvCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "preinstalled_capacities.csv")) %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  rename(preInvCap = value)

dataCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "optimal_capacities.csv")) %>%
  filter(type == "Generator",
         carrier != "Load shedding") %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  select(-type) %>%
  rename(cap = value)

dataCapInvestPyPSA <- full_join(dataPreInvCapPyPSA, dataCapPyPSA) %>%
  mutate(preInvCap = ifelse(is.na(preInvCap), 0, preInvCap),
         cap = ifelse(is.na(cap), 0, cap)) %>%
  mutate(deltaCap = cap - preInvCap) %>%
  rename(technology = carrier) %>%
  order.levels(technology = names(colorsTech)) %>%
  pivot_longer(cols = c("deltaCap", "preInvCap"),
               names_to = "variable",
               values_to = "value")

for (r in regList) {
  for (i in rmIterations){
    dataCapInvestREMINDplot <- dataCapInvestREMIND %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology, variable) %>%
      summarise(value = sum(value)) %>%
      filter(!is.na(value))

    dataCapInvestPyPSAplot <- dataCapInvestPyPSA %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology, variable) %>%
      summarise(value = sum(value))

    # Plot if there is data
    if ((nrow(dataCapInvestREMINDplot) > 0) | (nrow(dataCapInvestPyPSAplot) > 0)) {

    pCapInvest <- ggplot() +
      geom_bar(data = dataCapInvestREMINDplot,
              mapping = aes(x = year, y = value, alpha = variable, fill = technology, linetype = "REMIND"),
              stat = "identity",
              position = position_stacknudge(x = -1.2),
              color = "black",
              linewidth = 0.25,
              width = 2) +
      geom_bar(data = dataCapInvestPyPSAplot,
              mapping = aes(x = year, y = value, alpha = variable, fill = technology, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_stacknudge(x = 1.2),
              color = "black",
              linewidth = 0.25,
              width = 2) +
      scale_alpha_manual(
        name = "Capacity",
        values = c("deltaCap" = 0.5, "preInvCap" = 1),
        labels = c("deltaCap" = "Investment",
                  "preInvCap" = "Pre-investment")) +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid",
                  "PyPSA-Eur" = "dashed")) +
      guides(linetype = guide_legend(override.aes = list(fill = NA)),
             fill = "none") +
      labs(x = "Year", y = "Capacity (GW)") +
      ggtitle(paste("Pre-investment capacities and capacity expansion over years, iteration", i), regSubtitle(r)) +
      facet_wrap(~ technology, ncol = 2, scales = "free", labeller = labeller(technology = namesTech))

    print(pCapInvest)
    }
  }
}
```

### Pre-investment capacities and capacity expansion over iterations

```{r capacity expansion over iterations, fig.height = 3.5}
for (r in regList){
  for (y in years) {
    dataCapInvestREMINDplot <- dataCapInvestREMIND %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology, variable) %>%
      summarise(value = sum(value))

    dataCapInvestPyPSAplot <- dataCapInvestPyPSA %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology, variable) %>%
      summarise(value = sum(value))

    # Create plot
    pCapInvest <- ggplot() +
      geom_bar(data = dataCapInvestREMINDplot,
              mapping = aes(x = iteration, y = value, alpha = variable, fill = technology, linetype = "REMIND"),
              stat = "identity",
              position = position_stacknudge(x = -0.2),
              color = "black",
              linewidth = 0.25,
              width = 0.25) +
      geom_bar(data = dataCapInvestPyPSAplot,
              mapping = aes(x = iteration, y = value, alpha = variable, fill = technology, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_stacknudge(x = 0.2),
              color = "black",
              linewidth = 0.25,
              width = 0.25) +
      scale_alpha_manual(
        name = "Capacity",
        values = c("deltaCap" = 0.5, "preInvCap" = 1),
        labels = c("deltaCap" = "Investment",
                  "preInvCap" = "Pre-investment")) +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid",
                  "PyPSA-Eur" = "dashed")) +
      guides(linetype = guide_legend(override.aes = list(fill = NA)),
            fill = "none") +
      labs(x = "Iteration", y = "Capacity (GW)") +
      scale_x_continuous(breaks = rmIterations) +
      ggtitle(paste("Pre-investment capacities and capacity expansion over iterations, year", y), regSubtitle(r)) +
      facet_wrap(~ technology, ncol = 5, scales = "free", labeller = labeller(technology = namesTech))

    print(pCapInvest)
  }
}
```

### Optimal capacity over years

```{r optimal capacity over years, fig.height = 3.5}
# REMIND
dataCapREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "vm_cap",
  columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "value"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
  restoreZeros = FALSE,
  recalcUnit = 1e3)  # TW to GW

dataCapREMINDplot <- dataCapREMIND %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

# Also calculate minimum capacities from peak residual load
dataGenREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "v32_usableSeDisp",
  columns = c("ttot" = "year", "all_regi" = "region", "value" = "v32_usableSeDisp"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = FALSE,
  recalcUnit = 1E3)  # TWa to GWa

dataPeakResLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "peak_residual_loads.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(absolute = absolute / 1e3)  # Convert capacities to GW

dataPeakResLoadMinREMIND <- full_join(dataPeakResLoadPyPSA %>% mutate(iteration = iteration + 1),
                                      dataGenREMIND) %>%
  mutate(minCap = relative * v32_usableSeDisp)

# Read optimal capacities from the CSV files
dataCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "optimal_capacities.csv")) %>%
  mutate(value = value / 1e3) %>%  # Convert capacities to GW
  filter(!is.na(value),
         value > 0.1,
         carrier != "Load shedding")

dataCapPyPSAplot <- dataCapPyPSA %>%
  filter(type == "Generator") %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = sum(value)) %>%
  mutate(technology = as.factor(carrier)) %>%
  order.levels(technology = names(colorsTech))

for (r in regList){
  for (i in rmIterations){

    dataCapREMINDploti <- dataCapREMINDplot %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology) %>%
      summarise(value = sum(value))

    dataCapREMINDplotitot <- dataCapREMINDploti %>%
      group_by(year) %>%
      summarise(value = sum(value))

    dataCapPyPSAploti <- dataCapPyPSAplot %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology) %>%
      summarise(value = sum(value))

    dataCapPyPSAplotitot <- dataCapPyPSAploti %>%
      group_by(year) %>%
      summarise(value = sum(value))

    dataPeakResLoadMinREMINDplot <- dataPeakResLoadMinREMIND %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year) %>%
      summarise(minCap = sum(minCap))

    dataPeakResLoadPyPSAplot <- dataPeakResLoadPyPSA %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year) %>%
      summarise(minCap = sum(absolute))

    pCapComp <- ggplot() +
      geom_bar(data = dataCapREMINDploti,
              mapping = aes(x = year, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = -1.2),
              width = 2) +
      geom_bar(data = dataCapREMINDplotitot,
              mapping = aes(x = year, y = value, linetype = "REMIND"),
              stat = "identity",
              position = position_nudge(x = -1.2),
              width = 2,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_bar(data = dataCapPyPSAploti,
              mapping = aes(x = year, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = 1.2),
              width = 2) +
      geom_bar(data = dataCapPyPSAplotitot,
              mapping = aes(x = year, y = value, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_nudge(x = 1.2),
              width = 2,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_point(data = dataPeakResLoadMinREMINDplot,
                mapping = aes(x = year, y = minCap, shape = "Peak residual load"),
                position = position_nudge(x = -1.2),
                fill = "white") +
      geom_point(data = dataPeakResLoadPyPSAplot,
                mapping = aes(x = year, y = minCap, shape = "Peak residual load"),
                position = position_nudge(x = 1.2),
                fill = "white") +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech,
        guide = guide_legend(ncol = 2)
      ) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
      ) +
      scale_shape_manual(
        name = NULL,
        values = c("Peak residual load" = 23),
      ) +
      scale_x_continuous(breaks = years) +
      labs(x = "Year", y = "Capacity (GW)") +
      ggtitle(paste("Optimal capacity over years, iteration", i), regSubtitle(r))

    print(pCapComp)
  }
}
```

### Optimal capacity over iterations

```{r optimal capacity over iterations, fig.show = "hold", fig.width = 5, fig.height = 3.5}
for (r in regList) {
  for (y in years) {
    dataCapREMINDploty <- dataCapREMINDplot %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology) %>%
      summarise(value = sum(value))

    dataCapREMINDplotytot <- dataCapREMINDploty %>%
      group_by(iteration) %>%
      summarise(value = sum(value))

    dataCapPyPSAploty <- dataCapPyPSAplot %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology) %>%
      summarise(value = sum(value))

    dataCapPyPSAplotytot <- dataCapPyPSAploty %>%
      group_by(iteration) %>%
      summarise(value = sum(value))

    dataPeakResLoadMinREMINDplot <- dataPeakResLoadMinREMIND %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration) %>%
      summarise(minCap = sum(minCap))

    dataPeakResLoadPyPSAplot <- dataPeakResLoadPyPSA %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration) %>%
      summarise(minCap = sum(absolute))

    pCapComp <- ggplot() +
      geom_bar(data = dataCapREMINDploty,
              mapping = aes(x = iteration, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = -0.2),
              width = 0.25) +
      geom_bar(data = dataCapREMINDplotytot,
              mapping = aes(x = iteration, y = value, linetype = "REMIND"),
              stat = "identity",
              position = position_nudge(x = -0.2),
              width = 0.25,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_bar(data = dataCapPyPSAploty,
              mapping = aes(x = iteration, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = 0.2),
              width = 0.25) +
      geom_bar(data = dataCapPyPSAplotytot,
              mapping = aes(x = iteration, y = value, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_nudge(x = 0.2),
              width = 0.25,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_point(data = dataPeakResLoadMinREMINDplot,
                mapping = aes(x = iteration, y = minCap, shape = "Peak residual load"),
                position = position_nudge(x = -0.2),
                fill = "white") +
      geom_point(data = dataPeakResLoadPyPSAplot,
                mapping = aes(x = iteration, y = minCap, shape = "Peak residual load"),
                position = position_nudge(x = 0.2),
                fill = "white") +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech,
      ) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
      ) +
      scale_shape_manual(
        name = NULL,
        values = c("Peak residual load" = 23),
      ) +
      labs(x = "Iteration", y = "Capacity (GW)") +
      scale_x_continuous(breaks = rmIterations) +
      ggtitle(paste("Capacity over iterations, year", y), regSubtitle(r)) +
      theme(legend.position = "none")  # Don't show legend for now

    print(pCapComp)
  }
}
```

## Generation

### Generation in REMIND

The following plots are mostly useful to identify oscillations.

```{r generation in REMIND}
dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%  # TWa to TWh
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

for (r in regList) {
  dataGenREMINDplot <- dataGenREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(value = sum(value))

  pGenYear <- ggplot() +
    geom_line(data = dataGenREMINDplot, aes(x = year, y = value, color = technology)) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    labs(x = "Year", y = "Generation (TWh)") +
    ggtitle("Generation in REMIND over years", regSubtitle(r)) +
    facet_wrap(~ iteration)

  print(pGenYear)

  pGenIter <- ggplot() +
    geom_line(data = dataGenREMINDplot, aes(x = iteration, y = value, color = technology)) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    labs(x = "Iteration", y = "Generation (TWh)") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Generation in REMIND over iterations", regSubtitle(r)) +
    facet_wrap(~ year)

  print(pGenIter)
}
```

### Generation over years

```{r generation over years, fig.show = "hold", fig.height = 3.5}
# REMIND generation by technology
dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%  # TWa to TWh
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

# REMIND load in total
dataLoadREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE,
    recalcUnit = twa2twh)

# PyPSA-Eur generation by technology
dataGenPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "generations.csv")) %>%
  mutate(value = value / 1e6) %>%  # MWh to TWh
  mutate(technology = as.factor(carrier)) %>%
  order.levels(technology = names(colorsTech))

# PyPSA-Eur load in total
dataLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_loads.csv")) %>%
  mutate(value = value / 1e6)  # Convert MWh to TWh

for (r in regList) {
  for (i in rmIterations){

    dataGenREMINDploti <- dataGenREMIND %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology) %>%
      summarise(value = sum(value))

    dataGenREMINDplotitot <- dataGenREMINDploti %>%
      group_by(year) %>%
      summarise(value = sum(value))

    dataLoadREMINDploti <- dataLoadREMIND %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year) %>%
      summarise(value = sum(value))

    dataGenPyPSAploti <- dataGenPyPSA %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology) %>%
      summarise(value = sum(value))

    dataGenPyPSAplotitot <- dataGenPyPSAploti %>%
      group_by(year) %>%
      summarise(value = sum(value))

    dataLoadPyPSAploti <- dataLoadPyPSA %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year) %>%
      summarise(value = sum(value))

    pGenComp <- ggplot() +
      geom_bar(data = dataGenREMINDploti,
              mapping = aes(x = year, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = -1.2),
              width = 2) +
      geom_bar(data = dataGenREMINDplotitot,
              mapping = aes(x = year, y = value, linetype = "REMIND"),
              stat = "identity",
              position = position_nudge(x = -1.2),
              width = 2,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_point(data = dataLoadREMINDploti,
                 mapping = aes(x = year, y = value, color = "Load"),
                 position = position_nudge(x = -1.2),
                 shape = 4) +
      geom_bar(data = dataGenPyPSAploti,
              mapping = aes(x = year, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = 1.2),
              width = 2) +
      geom_bar(data = dataGenPyPSAplotitot,
              mapping = aes(x = year, y = value, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_nudge(x = 1.2),
              width = 2,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_point(data = dataLoadPyPSAploti,
                 mapping = aes(x = year, y = value, color = "Load"),
                 position = position_nudge(x = 1.2),
                 shape = 4) +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech,
        guide = guide_legend(ncol = 2)
      ) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
      ) +
      scale_color_manual(
        name = NULL,
        values = c("Load" = "black"),
      ) +
      scale_x_continuous(breaks = years) +
      labs(x = "Year", y = "Generation (TWh)") +
      ggtitle(paste("Generation over years, iteration", i), regSubtitle(r))

    print(pGenComp)
  }
}
```

### Generation over iterations

```{r generation over iterations, fig.show = "hold", fig.width = 5, fig.height = 3.5}
for (r in regList) {
  for (y in years) {

    dataGenREMINDploty <- dataGenREMIND %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology) %>%
      summarise(value = sum(value))

    dataGenREMINDplotytot <- dataGenREMINDploty %>%
      group_by(iteration) %>%
      summarise(value = sum(value))

    dataLoadREMINDploty <- dataLoadREMIND %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration) %>%
      summarise(value = sum(value))

    dataGenPyPSAploty <- dataGenPyPSA %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology) %>%
      summarise(value = sum(value))

    dataGenPyPSAplotytot <- dataGenPyPSAploty %>%
      group_by(iteration) %>%
      summarise(value = sum(value))

    dataLoadPyPSAploty <- dataLoadPyPSA %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration) %>%
      summarise(value = sum(value))

    pGenComp <- ggplot() +
      geom_bar(data = dataGenREMINDploty,
              mapping = aes(x = iteration, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = -0.2),
              width = 0.25) +
      geom_bar(data = dataGenREMINDplotytot,
              mapping = aes(x = iteration, y = value, linetype = "REMIND"),
              stat = "identity",
              position = position_nudge(x = -0.2),
              width = 0.25,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_point(data = dataLoadREMINDploty,
                 mapping = aes(x = iteration, y = value, color = "Load"),
                 position = position_nudge(x = -0.2),
                 shape = 4) +
      geom_bar(data = dataGenPyPSAploty,
              mapping = aes(x = iteration, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = 0.2),
              width = 0.25) +
      geom_bar(data = dataGenPyPSAplotytot,
              mapping = aes(x = iteration, y = value, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_nudge(x = 0.2),
              width = 0.25,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_point(data = dataLoadPyPSAploty,
                 mapping = aes(x = iteration, y = value, color = "Load"),
                 position = position_nudge(x = 0.2),
                 shape = 4) +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech,
      ) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
      ) +
      scale_color_manual(
        name = NULL,
        values = c("Load" = "black"),
      ) +
      labs(x = "Iteration", y = "Generation (TWh)") +
      scale_x_continuous(breaks = rmIterations) +
      ggtitle(paste("Generation over iterations, year", y), regSubtitle(r)) +
      theme(legend.position = "none")  # Don't show legend for now

    print(pGenComp)
  }
}
```

## Generation shares of REMIND technologies

Generation shares are not explicitly coupled between REMIND and PyPSA-Eur, but used to parametrise the pre-factor equations to avoid oscillations. If they don't converge, there is a always a distortion in the variables passed from PyPSA-Eur to REMIND.

```{r generation shares}

dataGenShareREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_shSeElDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE)

dataGenSharePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "generation_shares.csv")) %>%
  mutate(technology = as.factor(carrier))

unique_technologies <- unique(dataGenShareREMIND$technology)

techset1 <- unique_technologies[1:ceiling(length(unique_technologies) / 2)]
techset2 <- unique_technologies[(ceiling(length(unique_technologies) / 2) + 1):length(unique_technologies)]

techsets <- list(techset1, techset2)

for (r in regList) {
  for (t in techsets) {
    dataGenShareREMINDplot <- dataGenShareREMIND %>%
      filter(region %in% r,
             technology %in% t) %>%
      group_by(year, iteration, technology) %>%
      summarise(value = mean(value))  # TODO

    dataGenSharePyPSAplot <- dataGenSharePyPSA %>%
      filter(region %in% r,
             technology %in% t) %>%
      group_by(year, iteration, technology) %>%
      summarise(value = mean(value))  # TODO

    pGenShareYear <- ggplot() +
      geom_line(data = dataGenShareREMINDplot, aes(x = year, y = value, color = "REMIND")) +
      geom_line(data = dataGenSharePyPSAplot, aes(x = year, y = value, color = "PyPSA-Eur")) +
      scale_color_discrete(name = "Model") +
      labs(x = "Year", y = "Generation share") +
      ggtitle("Generation shares over years", regSubtitle(r)) +
      facet_grid(technology ~ iteration, scales = "free")

    print(pGenShareYear)

    pGenShareIter <- ggplot() +
      geom_line(data = dataGenShareREMINDplot, aes(x = iteration, y = value, color = "REMIND")) +
      geom_line(data = dataGenSharePyPSAplot, aes(x = iteration, y = value, color = "PyPSA-Eur")) +
      scale_color_discrete(name = "Model") +
      labs(x = "Iteration", y = "Generation share") +
      scale_x_continuous(breaks = rmIterations) +
      ggtitle("Generation shares over iterations", regSubtitle(r)) +
      facet_grid(technology ~ year, scales = "free")

    print(pGenShareIter)
  }
}
```

## Electricity price

```{r electricity price over years}
# REMIND
dataElecPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_SEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "value" = "pm_SEPrice"),
    colFilter = list("year" = years, "region" = regions, "secarrier" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh) %>%  # T$/TWa to $/MWh
  select(-secarrier)

# PyPSA-Eur
dataElecPricePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_prices.csv"))

pElecPriceYear <- ggplot() +
  geom_line(data = dataElecPriceREMIND,
            mapping = aes(x = year, y = pm_SEPrice, color = "REMIND")) +
  geom_line(data = dataElecPricePyPSA,
            mapping = aes(x = year, y = value, color = "PyPSA-Eur")) +
  scale_color_discrete(name = "Model") +
  labs(x = "Year", y = "Electricity price ($/MWh)") +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("Electricity price over years")

if (length(regions) > 1) {
  pElecPriceYear <- pElecPriceYear + facet_grid(region ~ iteration, scales = "free")
} else {
  pElecPriceYear <- pElecPriceYear + facet_wrap(~ iteration)
}

print(pElecPriceYear)

pElecPriceIter <- ggplot() +
  geom_line(data = dataElecPriceREMIND,
            mapping = aes(x = iteration, y = pm_SEPrice, color = "REMIND")) +
  geom_line(data = dataElecPricePyPSA,
            mapping = aes(x = iteration, y = value, color = "PyPSA-Eur")) +
  scale_color_discrete(name = "Model") +
  labs(x = "Iteration", y = "Electricity price ($/MWh)") +
  scale_x_continuous(breaks = rmIterations) +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("Electricity price over iterations")

if (length(regions) > 1) {
  pElecPriceIter <- pElecPriceIter + facet_grid(region ~ year, scales = "free")
} else {
  pElecPriceIter <- pElecPriceIter + facet_wrap(~ year)
}

print(pElecPriceIter)
```

## LCOEs

In the long-term equilibrium the levelised cost of electricity (LCOE) should be the same as the market value for each technology.

```{r lcoe remind2}

if (FALSE){
devtools::load_all("/p/tmp/adrianod/remind2_branches/remind2_LCOEReport")

lcoe.remind2 <- remind2::reportLCOE(rmFiles[7], output.type = "marginal")

test <- lcoe.remind2 %>%
  as_tibble() %>%
  filter(region == "DEU",
         output == "seel",
         cost != "Total LCOE",
         period >= 2025) %>%
  order.levels(cost = c("CO2 Tax Cost", "Fuel Cost", "OMV Cost", "OMF Cost", "Investment Cost", "Second Fuel Cost"))

p <- ggplot() + 
  geom_bar(data = test,
           mapping = aes(x = period, y = value, fill = cost),
           stat = "identity",
           position = "stack") +
  facet_wrap(~ tech, scales = "free")

print(p)
ggsave("lcoe_remind2.png")

}

```

### Simple LCOE

This section contains a simple calculation of the LCOE for each technology. It does not account for changes in the capacity factor, depreciation of capital stock and time-dependent components (i.e. fuel costs, CO2 prices).

This means, for example, that we can use the annuity factor for investment costs.

```{r LCOE simple}
if (FALSE) {

# REMIND: 1) Investment costs in USD/MWh
# Investment cost = Overnight cost (CAPEX) * annuity factor / (capfac * 8760h)

# Read overnight costs
vm_costTeCapital <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_costTeCapital",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_costTeCapital"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    recalcUnit = trUSDpTW2USDpMW)

# Read annuity factor
#p_teAnnuity <- readGDX(rmFiles[1], "p_teAnnuity") %>%
#  as_tibble() %>%
#  rename(technology = all_te, p_teAnnuity = value) %>%
#  select(!region)

# Calculate annuity factor using p_r
# Annuity factor = 1 / ( sum(opTimeYr, pm_omeg) / (1 + p_r)^optimeYr
# sum(opTimeYr, (sum(regi, pm_omeg(regi,opTimeYr,te))/sum(regi,1)) / 1.06**opTimeYr.val )
pm_omeg <- readGDX(rmFiles[1], "pm_omeg") %>%
  as_tibble() %>%
  rename(region = all_regi, technology = all_te, pm_omeg = value)

p_r <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p_r",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "p_r"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE)

annuityfactor <- right_join(pm_omeg, p_r, by = c("region"), relationship = "many-to-many") %>%
  group_by(region, year, technology, iteration) %>%
  summarise(annuityfactor = 1 / sum(pm_omeg / (1 + p_r)^opTimeYr))

# Calculate capacity factors for VRE technologies
vm_capFac <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_capFac",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_capFac"),
    colFilter = list(year = years, "region" = regions, "technology" = names(rm2genTech)))
    
teReNoBio <- readGDX(rmFiles[1], "teReNoBio")

vm_capDistr <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_capDistr",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "rlf", "value" = "vm_capDistr"),
    colFilter = list(year = years, "region" = regions, "technology" = teReNoBio),
    restoreZeros = FALSE)

pm_dataren <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataren",
    columns = c("all_regi" = "region", "all_te" = "technology", "char" = "char", "rlf" = "rlf", "value" = "pm_dataren_nur"),
    colFilter = list("region" = regions, "char" = "nur", "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-char) %>%
  replace_na(list(pm_dataren_nur = 0))

capfacVRE <- vm_capDistr %>%
  left_join(pm_dataren, relationship = "many-to-many") %>%
  left_join(vm_capFac) %>%
  replace_na(list(pm_dataren_nur = 0)) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(capfac = sum(vm_capFac * vm_capDistr * pm_dataren_nur) / sum(vm_capDistr)) %>%
  select(year, region, technology, capfac, iteration)

# Calculate capacity factors for dispatchable technologies
capfacDisp <- vm_capFac %>%
  filter(!(technology %in% teReNoBio)) %>%
  rename(capfac = vm_capFac)

capfac <- bind_rows(capfacVRE, capfacDisp)

# Calculate LCOE
lcoe.investment <- vm_costTeCapital %>%
  left_join(annuityfactor) %>%
  left_join(capfac) %>%
  mutate(lcoe = vm_costTeCapital * annuityfactor / (capfac * 8760)) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "investment")

# REMIND: FOM
pm_data_omf <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "char", "all_te" = "technology", "value" = "pm_data_omf"),
    colFilter = list("region" = regions, "char" = "omf", "technology" = names(rm2genTech)),
    restoreZeros = FALSE)

lcoe.fom <- vm_costTeCapital %>%
  left_join(pm_data_omf) %>%
  left_join(capfac) %>%
  mutate(lcoe = vm_costTeCapital * pm_data_omf / (capfac * 8760)) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "fom")

# REMIND: VOM
pm_data <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "char", "all_te" = "technology", "value" = "pm_data_omv"),
    colFilter = list("region" = regions, "char" = "omv", "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh)

lcoe.vom <- pm_data %>%
  tidyr::crossing(year = years) %>%
  rename(lcoe = pm_data_omv) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "vom")

# REMIND: Fuel costs
pm_eta_conv <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_eta_conv",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2pyTech))) %>%
  filter(eta > 0)

pm_dataeta <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataeta",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2pyTech)),
    restoreZeros = FALSE) %>%
  filter(eta > 0)

eta <- bind_rows(pm_eta_conv, pm_dataeta)

pe2seTech <- gdx::readGDX(rmFiles[1], "pe2se") %>%
  rename(pecarrier = all_enty,
         secarrier = all_enty1,
         technology = all_te) %>%
  filter(secarrier == "seel", technology %in% names(rm2pyTech)) %>%
  select(pecarrier, technology)

pm_PEPrice <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_PEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "pecarrier", "value" = "pm_PEPrice"),
    colFilter = list("year" = years, "region" = regions),
    recalcUnit = trUSDpTWa2USDpMWh)

lcoe.fuel <- pm_PEPrice %>%
  right_join(pe2seTech, by = c("pecarrier"), relationship = "many-to-many") %>%
  full_join(eta) %>%
  mutate(lcoe = pm_PEPrice / eta) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "fuel")

# REMIND: CO2 costs
p_priceCO2 <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "p_priceCO2",
  columns = c("tall" = "year", "all_regi" = "region", "value" = "p_priceCO2"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = TRUE,
  recalcUnit = 1 / tC2tCO2)

fm_dataemiglob_co2int <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "fm_dataemiglob",
    columns = c("all_enty" = "pecarrier", "all_enty1" = "secarrier", "all_te" = "technology", "all_enty2" = "gas", "value" = "co2int"),
    colFilter = list("secarrier" = "seel", "gas" = "co2", technology = names(rm2pyTech)),
    restoreZeros = FALSE,
    recalcUnit = 1E9 * tC2tCO2 / twa2mwh) %>%
  group_by(technology) %>%
  summarise(co2int = unique(co2int))

lcoe.co2 <- full_join(p_priceCO2, eta) %>%
  full_join(fm_dataemiglob_co2int) %>%
  replace_na(list(co2int = 0)) %>%
  mutate(lcoe = p_priceCO2 * co2int / eta) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "co2")

# Weights
dataGenTechREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

# Toal LCOEs
lcoeREMIND <- bind_rows(lcoe.investment, lcoe.fom, lcoe.vom, lcoe.fuel, lcoe.co2) %>%
  order.levels(type = c("co2", "fuel", "vom", "fom", "investment")) %>%
  full_join(dataGenTechREMIND) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, type, iteration) %>%
  summarise(lcoe = sum(lcoe * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp))

# Market value = electricity price and markups
dataElecPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_SEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "secarrier" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh) %>%  # T$/TWa to $/MWh
  tidyr::crossing(technology = names(rm2genTech)) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "elec")

dataMarkupREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_PyPSAMarkup",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_PyPSAMarkup"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh)

dataElecPlusMarkupREMIND <- dataElecPriceREMIND %>%
  left_join(dataMarkupREMIND) %>%
  mutate(value = value + vm_PyPSAMarkup) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "elec + markup")

# Peak capacity shadow price
dataPeakCapShadowPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PeakResLoadShadowPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PeakResLoadShadowPrice"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = trUSDpTWa2USDpMWh
  )

dataElecPlusMarkupPlusPeakShadowREMIND <- dataElecPlusMarkupREMIND %>%
  left_join(dataPeakCapShadowPriceREMIND) %>%
  mutate(value = value + p32_PeakResLoadShadowPrice) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "elec + markup + peakcap")

dataPricesREMIND <- bind_rows(dataElecPriceREMIND, dataElecPlusMarkupREMIND, dataElecPlusMarkupPlusPeakShadowREMIND) %>%
  order.levels(type = c("elec + markup + peakcap", "elec + markup", "elec")) %>%
  full_join(dataGenTechREMIND) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration, type) %>%
  summarise(value = sum(value * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp))

colorsInvest <- c(
  "co2" = "#e41a1c",
  "fuel" = "#377eb8",
  "vom" = "#4daf4a",
  "fom" = "#984ea3",
  "investment" = "#ff7f00")

labelsInvest <- c(
  "co2" = "CO2 cost",
  "fuel" = "Fuel cost",
  "vom" = "Variable O&M cost",
  "fom" = "Fixed O&M cost",
  "investment" = "Investment cost")

for (i in rmIterations) {
  p <- ggplot() +
    geom_bar(data = lcoeREMIND %>% filter(iteration == i),
            aes(x = year, y = lcoe, fill = type),
            stat = "identity",
            position = "stack",
            alpha = 0.8) +
    geom_line(data = dataPricesREMIND %>% filter(iteration == i),
              aes(x = year, y = value, linetype = type),
              linewidth = 0.5) +
    scale_linetype_manual(
      name = NULL,
      values = c("elec + markup + peakcap" = "solid",
                "elec + markup" = "dashed",
                "elec" = "dotted"),
      labels = c("elec + markup + peakcap" = "Elec. price + Markup +\nPeak capacity shadow price",
                "elec + markup" = "Elec. price + Markup",
                "elec" = "Elec. price"),
      guide = guide_legend(order = 1)
    ) +
    scale_fill_manual(
      name = "Cost component",
      values = colorsInvest,
      labels = labelsInvest,
      guide = guide_legend(order = 2)
    ) +
    labs(x = "Year", y = "LCOE ($/MWh)") +
    facet_wrap(~ technology, scales = "free", labeller = labeller(technology = namesTech)) +
    ggtitle("LCOE (simple) vs. electricity price and markup")

  print(p)
  }
}

```

```{r lcoe pypsa}

dataCostsPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  select(-further.description, -original_value, -source)

# PyPSA-Eur: Capital costs
dataCapex <- dataCostsPyPSA %>%
  filter(parameter == "investment")

dataLifetime <- dataCostsPyPSA %>%
  filter(parameter == "lifetime")

dataDisrate <- dataCostsPyPSA %>%
  filter(parameter == "discount_rate")

dataCapfac <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "capacity_factors.csv")) %>%
  revalue.levels(carrier = rm2pyTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(capfac = unique(value))

lcoe.investment <- dataCostsPyPSA %>%
  filter(parameter %in% c("investment", "lifetime", "discount_rate")) %>%
  select(-unit) %>%
  pivot_wider(names_from = parameter, values_from = value) %>%
  mutate(annuity = discount_rate / (1 - (1 + discount_rate)**(-lifetime))) %>%
  rename(carrier = technology) %>%
  full_join(dataCapfac) %>%
  mutate(lcoe = annuity * investment / (capfac * 8760))

# PyPSA-Eur: FOM
lcoe.fom <- dataCostsPyPSA %>%
  filter(parameter %in% c("investment", "FOM")) %>%
  select(-unit) %>%
  pivot_wider(names_from = parameter, values_from = value) %>%
  rename(carrier = technology) %>%
  full_join(dataCapfac) %>%
  mutate(lcoe = 1e-2 * investment * FOM / (capfac * 8760))  # FOM is in percent

# PyPSA-Eur: VOM


# PyPSA-Eur: Fuel costs


# PyPSA-Eur: CO2 costs


```

```{r lcoe complex}

if (FALSE) {




}

```

# Model-specific variables

## REMIND

### Electricity balance equation

This section shows all terms of REMIND's secondary energy electricity (`seel`) equation in `q32_balSe`.

### Sectoral electricity demand

## PyPSA-Eur

### Market values

```{r market values}
dataMarketValuePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "market_values.csv")) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  quitte::order.levels(carrier = names(namesTech))

pMarketValueYear <- ggplot() +
  geom_line(data = dataMarketValuePyPSA, aes(x = year, y = value, color = carrier)) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Year", y = "Market value ($/MWh)") +
  ggtitle("Market values by year")

if (length(regions) > 1) {
  pMarketValueYear <- pMarketValueYear + facet_grid(region ~ iteration, scales = "free")
} else {
  pMarketValueYear <- pMarketValueYear + facet_wrap(~ iteration)
}

print(pMarketValueYear)

pMarketValueIter <- ggplot() +
  geom_line(data = dataMarketValuePyPSA, aes(x = iteration, y = value, color = carrier)) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Iteration", y = "Market value ($/MWh)") +
  ggtitle("Market values by iteration")

if (length(regions) > 1) {
  pMarketValueIter <- pMarketValueIter + facet_grid(region ~ year, scales = "free")
} else {
  pMarketValueIter <- pMarketValueIter + facet_wrap(~ year)
}

print(pMarketValueIter)
```

### Price duration curves

```{r price duration curves, warning = FALSE}

dataHourlyElecPricesPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "hourly_electricity_prices.csv")) %>%
  pivot_longer(cols = -c("year", "region", "carrier", "iteration"),
               names_to = "time",
               values_to = "value") %>%
  group_by(year, region, carrier, iteration) %>%
  mutate(hour = 1:8760) %>%
  arrange(-value) %>%
  mutate(hour.sorted = 1:8760)

for (i in pyIterations) {
  dataHourlyElecPricesPyPSAplot <- dataHourlyElecPricesPyPSA %>%
    filter(iteration == i)

  pPriceDuration <- ggplot() +
    geom_line(data = dataHourlyElecPricesPyPSAplot,
              mapping = aes(x = hour.sorted, y = value, color = region)) +
    labs(x = "Hour", y = "Electricity price ($/MWh)") +
    ggtitle(paste("Price duration curve, iteration", i)) +
    scale_y_continuous(trans = "log10") +
    facet_wrap(~ year)

  print(pPriceDuration)
}
```

### Screening curves

### Inverse screening curves

### Residual load duration curves (RLDCs)

# Other plots

## VRE potentials

VRE potentials are constrained in terms of generation (TWa) in REMIND and in terms of capacity (GW) in PyPSA-Eur. REMIND VRE potentials in capacity terms therefore depend on the capacity factor as well, making them non-constant.

```{r vre potentials}
# Read vm_capFac (for dispatchable technologies)
vmCapFac <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "vm_capFac",
  columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vmCapFac"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Read vm_capDistr (for VRE technologies)
vmCapDistr <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "vm_capDistr",
  columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "rlf", "value" = "vmCapDistr"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Read pm_dataren (nur)
pmDatarenNur <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataren",
    columns = c("all_regi" = "region", "all_te" = "technology", "char" = "char", "rlf" = "rlf", "value" = "pmDatarenNur"),
    colFilter = list("region" = regions, "char" = "nur", "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-char)

# Read pm_dataren (maxprod)
pmDatarenMaxprod <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataren",
    columns = c("all_regi" = "region", "all_te" = "technology", "char" = "char", "rlf" = "rlf", "value" = "pmDatarenMaxprod"),
    colFilter = list("region" = regions, "char" = "maxprod", "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-char) %>%
  replace_na(list(pmDatarenMaxprod = 0))

# Calculate VRE potential in GW in REMIND
dataVREpotREMIND <- pmDatarenMaxprod %>%
  left_join(pmDatarenNur) %>%
  left_join(vmCapFac, relationship = "many-to-many") %>%
  group_by(region, technology, year, iteration) %>%
  # Calculate according to q_limitProd and transform TW to GW
  summarise(value = 1E3 * sum(pmDatarenMaxprod / (pmDatarenNur * vmCapFac))) %>%
  ungroup() %>%
  revalue.levels(technology = rm2genTech) %>%
  order.levels(technology = names(colorsTech))

# PyPSA-Eur
dataVREpotPyPSA <- readPyPSAcsv(paths = file.path(pyValidationDirs, "potentials.csv")) %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  filter(!is.na(value),
         !is.infinite(value)) %>%
  rename(technology = carrier) %>%
  order.levels(technology = names(colorsTech))

pVREpot <- ggplot() +
  geom_line(data = dataVREpotREMIND,
            mapping = aes(x = year, y = value, color = region)) +
  geom_point(data = dataVREpotPyPSA,
            mapping = aes(x = year, y = value, color = region)) +
  labs(x = "Year", y = "VRE potential (GW)") +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("VRE potential over years") +
  facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech))

print(pVREpot)
```

## Original PyPSA-Eur costs vs. REMIND costs

```{r original pypsa vs remind costs}

# Read PyPSA-Eur costs
dataCostsPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(source == "REMIND-EU")

```
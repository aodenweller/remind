---
title: "REMIND-PyPSA-Eur Validation"
author: "Adrian Odenweller, Johannes Hampp"
date: "2023-07-12"
output:
  pdf_document:
    number_sections: true
    fig_width: 10
    fig_height: 6
    extra_dependencies: ["float"]
params:
  pyDir: "/p/tmp/adrianod/pypsa-eur"
fontsize: 11pt
geometry: margin=0.5in
---

This RMarkdown file contains various plots for validation of the REIMND-PyPSA-Eur model coupling.

```{r setup, include=FALSE}
# Load libraries
library(gdx)
library(tidyverse)

knitr::opts_chunk$set(dpi = 300, fig.pos = "H", out.extra = "")
theme_set(theme_bw())

# Color mapping
colorsTech <- c(
  "solar" = "#ffcc00",
  "onwind" = "#337fff",
  "all_offwind" = "#334cff",
  "offwind" = "#334cff",
  "biomass" = "#005900",
  "ror" = "#191999",
  "CCGT" = "#999959",
  "OCGT" = "#e5e5b2",
  "oil" = "#663a00",
  "all_coal" = "#0c0c0c",
  "coal" = "#0c0c0c",
  "lignite" = "#392306",
  "nuclear" = "#ff33ff"
  )

# Pretty names
namesTech <- c(
  "solar" = "Solar",
  "onwind" = "Wind Onshore",
  "all_offwind" = "Wind Offshore",
  "offwind" = "Wind Offshore",
  "biomass" = "Biomass",
  "ror" = "Run of river",
  "CCGT" = "CCGT",
  "OCGT" = "OCGT",
  "oil" = "Oil",
  "all_coal" = "Coal+Lignite",
  "coal" = "Coal",
  "lignite" = "Lignite",
  "nuclear" = "Nuclear")

# Technology mapping: REMIND to General
rm2genTech <- c(
  "biochp" = "biomass",
  "bioigcc" = "biomass",
  "bioigccc" = "biomass",
  "ngcc" = "CCGT",
  "ngccc" = "CCGT",
  "gaschp" = "CCGT",
  "igcc" = "all_coal",
  "igccc" = "all_coal",
  "pc" = "all_coal",
  "coalchp" = "all_coal",
  "tnrs" = "nuclear",
  "fnrs" = "nuclear",
  "ngt" =  "OCGT",
  "windoff" = "all_offwind",  # Or just offwind?
  "dot" = "oil",
  "wind" = "onwind",
  "hydro" = "ror",
  "spv" = "solar"
  )

# Technology mapping: General to REMIND
gen2rmTech <- c(
  "biomass" = "biomass",
  "CCGT" = "CCGT",
  "coal" = "all_coal",  # Aggregate coal
  "lignite" = "all_coal",  # Aggregate coal
  "nuclear" = "nuclear",
  "OCGT" = "OCGT",
  "offwind-ac" = "all_offwind",  # Aggregate offshore wind
  "offwind-dc" = "all_offwind",  # Aggregate offshore wind
  "oil" = "oil",
  "onwind" = "onwind",
  "ror" = "ror",
  "solar" = "solar"
)

# Years to plot
years <- c(seq(2025, 2060, 5), seq(2070, 2110, 10), 2130, 2150)

# Regions to plot
regions <- "DEU"

# Unit conversions
twa2twh <- 8760
tC2tCO2 <- 44/12

```

# Get REMIND and PyPSA-Eur files

```{r data, echo=FALSE}

# REMIND directories
rmOutdir <- getwd()
scenario <- basename(rmOutdir)  # Scenario name
# REMIND fulldata.gdx files
rmFulldataFiles <- list.files(
  rmOutdir,
  pattern = "fulldata\\_\\d{1,}.gdx",
  full.names = TRUE)
# REMIND2PyPSAEUR.gdx files
rm2pyFiles <- list.files(
  rmOutdir,
  pattern = "REMIND2PyPSAEUR\\_\\d{1,}.gdx",
  full.names = TRUE)
# PyPSAEUR2REMIND.gdx files
py2rmFiles <- list.files(
  rmOutdir,
  pattern = "PyPSAEUR2REMIND\\_\\d{1,}.gdx",
  full.names = TRUE
)

# PyPSA directories
load("config.Rdata")
pyDir <- cfg$gms$c32_pypsa_dir  # Get PyPSA-Eur directory from config.Rdata
pyResultsDir <- file.path(pyDir, "results", scenario)
# Get subdirectories labeled "i" for iteration followed by an integer number
pyResultsDirs <- list.dirs(pyResultsDir,
                            recursive = FALSE,
                            full.names = TRUE)

# Some logging
cat(paste("Found", length(rmFulldataFiles), "REMIND fulldata_i.gdx files.\n"))
cat(paste("Found", length(rm2pyFiles), "REMIND2PyPSAEUR_i.gdx files.\n"))
cat(paste("Found", length(pyResultsDirs), "PyPSA-EUR iteration directories.\n"))
cat(paste("Found", length(py2rmFiles), "PyPSAEUR2REMIND_i.gdx files.\n"))

# Throw warning if number of files does not match
if (length(unique(c(length(rmFulldataFiles), length(rm2pyFiles), length(pyResultsDirs), length(py2rmFiles)))) != 1) {
  warning("Number of REMIND and PyPSA-Eur files does not match.\n")
}

```

```{r helpers, include = FALSE, echo = FALSE}

# This function reads in csv files in the PyPSA-Eur directory
# Expected path: <PyPSA-Eur results folder>/i<iteration>/<some file>.csv
readPyPSAcsv <- function(paths) {
  map_df(paths, ~{
    # Extract iteration from path
    iteration <- as.integer(str_extract(.x, "(?<=i)\\d{1,}(?=/)"))
    # Try to read csv file
    tryCatch(
      {
        read.csv(.x, header = TRUE) %>% 
          mutate(iteration = iteration)
      },
      error = function(e) {
        cat("Error reading file:", .x, "\n")
        tibble() # Return an empty tibble in case of an error
      }
    )
  })
}

# This function reads in gdx files into tibbles
# rmFile: Path to gdx file
# gdxVar: Name of gdx variable to read
# columns: Named *vector* of columns to select and rename
# colFilter: *List* of renamed columns and values to filter for
readGDX <- function(rmFile, gdxVar, columns, colFilter,
                    restoreZeros = TRUE, field = "l", recalcUnit = 1) {
  # Read gdx file
  data <- gdx::readGDX(rmFile, gdxVar, restore_zeros = restoreZeros, field = field) %>%
    as_tibble(.name_repair = "unique")
  # If data is empty create tibble with columns from colFilter and column "value" filled with 0
  if (nrow(data) == 0) {
    data <- tibble(expand.grid(colFilter), value = 0)
  } else {
     data <- data %>% 
      # Select desired columns and rename
      select_at(names(columns), ~ columns) %>%
      # Filter columns according to colFilter
      filter(if_all(names(colFilter), ~ . %in% colFilter$.)) %>% 
      # Multiply by recalcUnit
      mutate(across(columns["value"][[1]], ~ . * recalcUnit))
  }
  return(data)
}

# This function reads in multiple fulldata_<iteration>.gdx files from REMIND
readREMINDgdx <- function(paths, gdxVar, columns, colFilter,
                          restoreZeros = TRUE, field = "l", recalcUnit = 1) {
  map_df(paths, ~{
    # Extract iteration from path
    iteration <- as.integer(str_extract(.x, "(?<=(fulldata_)|(REMIND2PyPSAEUR_))\\d{1,}(?=.gdx)"))
    readGDX(.x, gdxVar, columns, colFilter, restoreZeros, field, recalcUnit) %>%
      mutate(iteration = iteration)
  })
}

```

# General model information

## Runtime PyPSA-EUR

Runtime for PyPSA-EUR required for each iteration from start of first job to end of last job, based on the change time of the "co2_price_scenarios.csv" and "PyPSAEUR2REMIND.gdx" files.

```{r runtime, echo = FALSE, message = FALSE}

# Get last change time and creation time of "co2_price_scenarios.csv" and "PyPSAEUR2REMIND.gdx" in each directory
fileTimes <- lapply(pyResultsDirs, function(dir) {
  co2PriceFile <- file.path(dir, "co2_price_scenarios.csv")
  couplingFile <- file.path(dir, "PyPSAEUR2REMIND.gdx")
  co2PriceCtime <- file.info(co2PriceFile)$ctime
  couplingCtime <- file.info(couplingFile)$ctime
  timeDiff <- difftime(couplingCtime, co2PriceCtime, units = "mins")
  iteration <- gsub("i", "", basename(dir))
  return(list(directory = dir, iteration = iteration, co2_price_last_change_time = co2PriceCtime, coupling_creation_time = couplingCtime, time_diff = timeDiff))
})

# Combine results into a data frame
fileTimes <- do.call(rbind.data.frame, fileTimes)

# Print results
print(fileTimes)

# Plot the time difference for each iteration as a bar plot
pTimeDiff <- ggplot() +
  geom_bar(data = fileTimes, aes(x = iteration, y = time_diff), stat = "identity") +
  labs(x = "Iteration", y = "Runtime [minutes]") +
  ggtitle("Runtime for PyPSA-EUR") + 
  ylim(0, NA)

print(pTimeDiff)
    
```

# Coupled variables

This section includes plots of all variables that are exchanged between REMIND
and PyPSA-Eur.

## REMIND to PyPSA-Eur

This section includes variables that are transferred from REMIND to PyPSA-Eur (displayed as lines).
Values used by PyPSA-EUR are also retrieved to cross-check (displayed as points).

### Electricity load

```{r load, echo = FALSE, message = FALSE}

# Read REMIND data
dataLoadREMIND <- readREMINDgdx(
  paths = rm2pyFiles,
  gdxVar = "v32_usableSeDisp",
  columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "technology", "value" = "value"),
  colFilter = list("year" = years, "region" = regions, "technology" = "seel"),
  restoreZeros = FALSE,
  recalcUnit = twa2twh)

# Load PyPSAEUR electricity loads for cross-checking
dataLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyResultsDirs, "electricity_loads.csv")) %>% 
  mutate(value = value / 1e6)  # Convert MWh to TWh

# Plot by year
pYear <- ggplot() +
  geom_line(data = dataLoadREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataLoadPyPSA, aes(x = year, y = value, color = region)) +
  labs(x = "Year", y = "Electricity load (TWh)") +
  ggtitle("Electricity load by year") +
  facet_wrap(~ iteration)

# Plot by iteration
pIter <- ggplot() +
  geom_line(data = dataLoadREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataLoadPyPSA, aes(x = iteration, y = value, color = region)) +
  labs(x = "Iteration", y = "Electricity load (TWh)") +
  ggtitle("Electricity load by iteration") +
  facet_wrap(~ year)

print(pYear)

print(pIter)

```

### Pre-investment capacities

This could also be merged into a joint plot that shows both pre-investment and additional optimised capacities.

```{r pre-investment capacities, echo = FALSE, message = FALSE}

# Read REMIND data
dataPreInvestREMIND <- readREMINDgdx(
  paths = rm2pyFiles,
  gdxVar = "p32_preInvCap",
  columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = TRUE,
  recalcUnit = 1e3)  # TW to GW

# Read PyPSA-Eur data
dataPreInvestPyPSA <- readPyPSAcsv(
  paths = file.path(pyResultsDirs, "installed_capacities.csv")) %>% 
  mutate(value = value / 1e3)  # Convert capacities to GW

# Plot by year
pYear <- ggplot() +
  geom_line(data = dataPreInvestREMIND, aes(x = year, y = value, color = technology)) +
  geom_point(data = dataPreInvestPyPSA, aes(x = year, y = value, color = carrier)) +
  labs(x = "Year", y = "Capacity (GW)") +
  ggtitle("Pre-investment capacity by year") +
  facet_wrap(~ iteration, scales = "free")

# Plot by iteration
pIter <- ggplot() +
  geom_line(data = dataPreInvestREMIND, aes(x = iteration, y = value, color = technology)) +
  geom_point(data = dataPreInvestPyPSA, aes(x = iteration, y = value, color = carrier)) +
  labs(x = "Iteration", y = "Capacity (GW)") +
  ggtitle("Pre-investment capacity by iteration") +
  facet_wrap(~ year, scales = "free")

print(pYear)

print(pIter)

```

### Specific capital costs

### Fixed O&M costs

### Fuel costs

### Variable O&M costs

### Efficiencies

### Lifetimes

### Discount rate

### CO2 prices

```{r co2 price, echo = FALSE, message = FALSE}

# TODO load REMIND data to cross-check with values used by PyPSA-Eur
dataCO2PriceREMIND <- readREMINDgdx(
  paths = rm2pyFiles,
  gdxVar = "p_priceCO2",
  columns = c("tall" = "year", "all_regi" = "region", "value" = "value"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = TRUE,
  recalcUnit = tC2tCO2
)

# Read the CO2 prices from the CSV files
dataCO2PricePyPSA <- readPyPSAcsv(
    paths = file.path(pyResultsDirs, "co2_price_scenarios.csv")) %>% 
  # Extract the CO2 price from the opts columns which starts with Ep followed by a number of format 0.0
  mutate(value = as.numeric(str_extract(opts, "(?<=Ep)\\d+\\.\\d{1,2}")))

# Plot by year
pYear <- ggplot() +
  geom_line(data = dataCO2PriceREMIND, aes(x = year, y = value)) +
  geom_point(data = dataCO2PricePyPSA, aes(x = year, y = value)) +
  labs(x = "Year", y = "CO2 price (EUR/tCO2)") +
  ggtitle("CO2 price by year") +
  facet_wrap(~ iteration)

# Plot by iteration
pIter <- ggplot() +
  geom_line(data = dataCO2PriceREMIND, aes(x = iteration, y = value)) +
  geom_point(data = dataCO2PricePyPSA, aes(x = iteration, y = value)) +
  labs(x = "Iteration", y = "CO2 price (EUR/tCO2)") +
  ggtitle("CO2 price by iteration") +
  facet_wrap(~ year)

print(pYear)

print(pIter)

```

## PyPSA-Eur to REMIND

This section includes variables that are transferred from PyPSA-Eur to REMIND (displayed as points).
Values used by REMIND are also retrieved to cross-check (displayed as lines).

### Capacity factors

```{r capacity factors, echo = FALSE, message = FALSE}

# REMIND capacity factors
# Capacity factors are handled differently for dispatchable and VRE technologies

# Read vm_capFac (for dispatchable technologies)
vmCapFac <- readREMINDgdx(
  paths = rmFulldataFiles,
  gdxVar = "vm_capFac",
  columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vmCapFac"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Read vm_capDistr (for VRE technologies)
vmCapDistr <- readREMINDgdx(
  paths = rmFulldataFiles,
  gdxVar = "vm_capDistr",
  columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "rlf", "value" = "vmCapDistr"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Read pm_dataren (for VRE technologies)
pmDataren <- readREMINDgdx(
  paths = rmFulldataFiles,
  gdxVar = "pm_dataren",
  columns = c("all_regi" = "region", "all_te" = "technology", "char" = "char", "rlf" = "rlf", "value" = "pmDataren"),
  colFilter = list("region" = "DEU", "char" = "nur", "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Read teReNoBio set (for VRE technologies)
teReNoBio <- gdx::readGDX(rmFulldataFiles[1], "teReNoBio", restore_zeros = FALSE)

# Calculate capacity factor for VRE technologies
capfacRlf <- vmCapFac %>%
  filter(.data$technology %in% teReNoBio) %>%
  full_join(vmCapDistr %>%
              filter(.data$technology %in% teReNoBio)) %>%
  full_join(pmDataren %>%
              filter(.data$technology %in% teReNoBio)) %>%
  # Filter away rlfs that are not used
  filter(!is.na(pmDataren)) %>%
  group_by(.data$year, .data$region, .data$technology, .data$iteration) %>%
  summarise(capfac = sum(vmCapFac * vmCapDistr * pmDataren) / sum(vmCapDistr))

# Capacity factor for non-rlf technologies
capfacNoRlf <- vmCapFac %>%
  filter(!(.data$technology %in% teReNoBio)) %>%
  group_by(.data$year, .data$region, .data$technology, .data$iteration) %>%
  dplyr::transmute(capfac = vmCapFac)

# Combine capacity factors for all technologies
dataCapfacREMIND <- bind_rows(capfacRlf, capfacNoRlf) %>%
  quitte::revalue.levels(technology = rm2genTech) %>%
  group_by(.data$year, .data$region, .data$technology, .data$iteration) %>%
  mutate(dummy = ifelse(iteration > 1,
                        as.integer(dplyr::n_distinct(.data$capfac) == 1),
                        1))

# Throw warning if some capacity factors don't match within group
if (any(dataCapfacREMIND$dummy == 0)) {
  techProb <- as.character(unique(remind$technology[remind$dummy == 0]))
  warning(paste("Capacity factors for", techProb, "don't match.\n"))
  }

# REMIND data for plotting
dataCapfacREMINDplot <- dataCapfacREMIND %>%
  # Take the average of all general technologies
  # Values should be the same as they come from PyPSA-Eur
  # However, in iterations before PyPSA starts, they are not the same
  summarise(capfac = mean(.data$capfac)) %>%
  quitte::order.levels(technology = names(colorsTech)) %>%
  rename(value = capfac)

# PyPSA-Eur capacity factors
dataCapfacPyPSA <- readPyPSAcsv(
  paths = file.path(pyResultsDirs, "capacity_factors.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(.data$year, .data$region, .data$carrier, .data$iteration) %>%
  summarise(value = unique(.data$value))


# Plot by year
pCapfacYear <- ggplot() +
  # Layer 1: REMIND
  geom_line(data = dataCapfacREMINDplot, aes(x = year, y = value, color = technology)) +
  # Layer 2: PyPSA-Eur
  geom_point(data = dataCapfacPyPSA, aes(x = year, y = value, color = carrier)) +
  # Legend formatting
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Year", y = "Capacity factor") +
  ggtitle("Capacity factor, iterations in panels") +
  facet_wrap(~ iteration)

# Plot by iteration
pCapfacIter <- ggplot() +
  # Layer 1: REMIND
  geom_line(data = dataCapfacREMINDplot, aes(x = iteration, y = value, color = technology)) +
  # Layer 2: PyPSA-Eur
  geom_point(data = dataCapfacPyPSA, aes(x = iteration, y = value, color = carrier)) +
  # Legend formatting
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Iteration", y = "Capacity factor") +
  ggtitle("Capacity factor, years in panels") +
  facet_wrap(~ year)

print(pCapfacYear)

print(pCapfacIter)

```

### Market values

```{r market values, echo = FALSE, message = FALSE}

# REMIND data
#dataMarketValueREMIND <- ...


dataMarketValuePyPSA <- readPyPSAcsv(
  paths = file.path(pyResultsDirs, "market_values.csv")) %>% 
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>% 
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(.data$year, .data$region, .data$carrier, .data$iteration) %>%
  summarise(value = unique(.data$value)) %>% 
  quitte::order.levels(carrier = names(namesTech))

pMarketValueYear <- ggplot() +
  # Layer 1: REMIND
  #geom_line(data = dataMarketValueREMIND, aes(x = year, y = value, color = technology)) +
  # Layer 2: PyPSA-Eur
  geom_point(data = dataMarketValuePyPSA, aes(x = year, y = value, color = carrier)) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Year", y = "Market value ($/MWh)") +
  ggtitle("Market values by year") +
  facet_wrap(~ iteration)

pMarketValueIter <- ggplot() +
  # Layer 1: REMIND
  #geom_line(data = dataMarketValueREMIND, aes(x = iteration, y = value, color = technology)) +
  # Layer 2: PyPSA-Eur
  geom_point(data = dataMarketValuePyPSA, aes(x = iteration, y = value, color = carrier)) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Iteration", y = "Market value ($/MWh)") +
  ggtitle("Market values by iteration") +
  facet_wrap(~ year)

print(pMarketValueYear)

print(pMarketValueIter)

```

## Markups / Markdowns

Markups and markdowns are read into REMIND from PYPSA-Eur.

Markup = Average market value - Average electricity price

# Non-coupled variables

This section includes plots of several key variables that are not coupled
between REMIND and PyPSA-Eur, but that should get harmonised.

## Capacities

Work in progress...

```{r capacities, echo = FALSE, message = FALSE}

# REMIND
dataCapREMIND <- readREMINDgdx(
  paths = rmFulldataFiles,
  gdxVar = "vm_cap",
  columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "value"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
  restoreZeros = FALSE,
  recalcUnit = 1e3)  # TW to GW

# Aggregate generalised technologies to aggregated PyPSA-Eur technologies
gen2pyAggTech <- c(
  "biomass" = "Biomass",
  "CCGT" = "Combined-Cycle Gas",
  "all_coal" = "Coal+Lignite",
  "nuclear" = "Nuclear",
  "OCGT" = "Open-Cycle Gas",
  "all_offwind" = "Offshore Wind",
  "oil" = "Oil",
  "onwind" = "Onshore Wind",
  "ror" = "Run of River",
  "solar" = "Solar"
)
dataCapREMINDagg <- dataCapREMIND %>% 
  quitte::revalue.levels(technology = rm2genTech) %>%
  quitte::revalue.levels(technology = gen2pyAggTech) %>% 
  group_by(.data$year, .data$region, .data$technology, .data$iteration) %>%
  summarise(value = sum(.data$value))

# Read optimal capacities from the CSV files
dataCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyResultsDirs, "optimal_capacities.csv")) %>% 
  mutate(value = value / 1e3) %>%  # Convert capacities to GW
  filter(!is.na(value),
         value > 0.1,
         carrier != "Load shedding")

# Aggregate PyPSA-Eur technologies to aggregated PyPSA-Eur technologies
py2pyAggTech <- c(
  "Offshore Wind (DC)" = "Offshore Wind",
  "Offshore Wind (AC)" = "Offshore Wind",
  "Coal" = "Coal+Lignite",
  "Lignite" = "Coal+Lignite"
)
dataCapPyPSAagg <- dataCapPyPSA %>%
  filter(type == "Generator") %>%
  quitte::revalue.levels(carrier = py2pyAggTech) %>% 
  group_by(.data$year, .data$carrier, .data$iteration) %>%
  summarise(value = sum(.data$value)) %>%
  mutate(technology = as.factor(carrier))

p <- ggplot() +
  geom_bar(data = dataCapREMINDagg,
           mapping = aes(x = year, y = value, fill = "REMIND"),
           stat = "identity",
           position = position_nudge(x = -0.5),
           width = 1) +
  geom_bar(data = dataCapPyPSAagg,
           mapping = aes(x = year, y = value, fill = "PyPSA-Eur"),
           stat = "identity",
           position = position_nudge(x = 0.5),
           width = 1) +
  labs(x = "Year", y = "Capacity (GW)") +
  ggtitle("Capacity by year") +
  facet_grid(technology ~ iteration, scales = "free")

print(p)

# Sum over all carriers and group the results by type
dataCapPyPSAtype <- dataCapPyPSA %>% 
  group_by(type, year, iteration) %>% 
  summarise(value = sum(value))

# Plot the summed values by type, with subplots for each type, the x axis for years and a line per plot for the different itations
pType <- ggplot() +
  geom_point(data = dataCapPyPSAtype, aes(x = year, y = value, color = factor(iteration))) +
  geom_line(data = dataCapPyPSAtype, aes(x = year, y = value, color = factor(iteration))) +
  labs(x = "Year", y = "Capacity (GW)") +
  ggtitle("Optimal capacity by type") +
  facet_wrap(~ type)

print(pType)

pYear <- ggplot() +
  geom_bar(data = dataCapPyPSA, aes(x = year, y = value), stat = "identity", position_dodge(width = 0.9)) +
  labs(x = "Technology", y = "Capacity (GW)") +
  ggtitle("Capacity by iteration") +
  facet_grid(carrier ~ iteration, scales = "free") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

print(pYear)

```

## Generation

## Electricity price

# Model-specific variables

## REMIND

## PyPSA-Eur

### Screening curves

### Inverse screening curves

### Residual load duration curves (RLDCs)


---
title: "REMIND-PyPSA-Eur Validation"
author: "Adrian Odenweller, Johannes Hampp"
date: "`r format(Sys.time())`"
output:
  pdf_document:
    number_sections: true
    toc: true
    toc_depth: 3
#    fig_width: 11
#    fig_height: 7.5
    extra_dependencies: ["xcolor"]
fontsize: 11pt
geometry: "a4paper,landscape,left=0.5cm,right=0.5cm,top=0.5cm,bottom=0.5cm,footnotesep=0.0cm,footskip=0.1cm"
documentclass: article
---

\newpage

```{r setup, include=FALSE}
# Load libraries
library(gdx)
library(tidyverse)
library(stringr)
library(quitte)
library(ggpp)
library(ggnewscale)
library(cowplot)
library(lubridate)

# Set options for all chunks
knitr::opts_chunk$set(
  dpi = 300,
  echo = FALSE,
  message = FALSE,
  cache = FALSE,
  dev = c("png", "pdf"),
  dev.args = list(png = list(type = "cairo", family = "sans"), pdf = list(family = "sans", bg = "transparent")),
  fig.align = "center",
  fig.width = 11,
  fig.height = 7.5,
  fig.path = "REMIND-PyPSA_Validation_Figures/")

font.size <- 8

# Set ggplot2 theme
theme_set(theme_bw(base_size = font.size))

# Print error and warning messages in red
color_block <- function(color) {
  function(x, options) paste0('\\color{', color, '}\\begin{verbatim}', x, '\\end{verbatim}\\color{black}')
}
knitr::knit_hooks$set(
  warning = color_block('red'),
  error = color_block('red'))

```

# Get REMIND and PyPSA-Eur files

```{r data}
load("config.Rdata")

# REMIND directories
rmOutdir <- getwd()
scenario <- basename(rmOutdir)  # Scenario name
# Print REMIND directory
cat("REMIND directory:", rmOutdir, "\n")
# REMIND fulldata_i.gdx files
rmFulldataFiles <- list.files(
  rmOutdir,
  pattern = "fulldata_\\d{1,}.gdx",
  full.names = TRUE)
# REMIND non_optimal_i.gdx files
rmNonOptimalFiles <- list.files(
  rmOutdir,
  pattern = "non_optimal_\\d{1,}.gdx",
  full.names = TRUE)
# REMIND fulldata_i.gdx and non_optimal_i.gdx files
rmFilesAll <- c(rmFulldataFiles, rmNonOptimalFiles)
# Only use rmFiles for which iteration is larger than cfg$gms$c32_startIter_PyPSA
rmFiles <- rmFilesAll[as.numeric(gsub(".*_([0-9]+)\\.gdx", "\\1", rmFilesAll)) >= cfg$gms$c32_startIter_PyPSA]
# REMIND2PyPSAEUR.gdx files
rm2pyFiles <- list.files(
  rmOutdir,
  pattern = "REMIND2PyPSAEUR_\\d{1,}.gdx",
  full.names = TRUE)
# PyPSAEUR2REMIND.gdx files
py2rmFiles <- list.files(
  rmOutdir,
  pattern = "PyPSAEUR2REMIND_\\d{1,}.gdx",
  full.names = TRUE
)
# Get iterations from rmFiles and sort
rmIterations <- as.numeric(gsub(".*_([0-9]+)\\.gdx", "\\1", rmFiles)) %>%
  sort()
everyIter <- cfg$gms$c32_everyIter_PyPSA

# PyPSA directories
pyDir <- cfg$gms$c32_pypsa_dir  # Get PyPSA-Eur directory from config.Rdata
# Print PyPSA-Eur directory
cat("PyPSA-Eur directory:", pyDir, "\n")
# PyPSA-Eur resources and results directories
pyResourcesDir <- file.path(pyDir, "resources", scenario)
pyResultsDir <- file.path(pyDir, "results", scenario)
# Get subdirectories labeled "i" for iteration followed by an integer number
pyResultsDirs <- list.dirs(pyResultsDir,
                           recursive = FALSE,
                           full.names = TRUE)
# Get validation subdirectories labeled "validation"
pyValidationDirs <- list.dirs(pyResultsDirs,
                              recursive = FALSE,
                              full.names = TRUE) %>%
  keep(str_detect(., "validation"))
# Get resources subdirectories labeled "i" for iteration and "y" for year
pyResourcesDirs <- list.dirs(pyResourcesDir,
                             recursive = TRUE,
                             full.names = TRUE) %>%
  keep(str_detect(., "y\\d{4}$"))
# Get iteration from PyPSA-Eur validation directories
pyIterations <- as.numeric(gsub(".*i([0-9]+).*", "\\1", pyValidationDirs)) %>%
  sort()

# Some logging
cat("Found", length(rmFulldataFiles), "REMIND fulldata_i.gdx files.\n")
if (length(rmNonOptimalFiles) > 0) {
  warning((paste("Found", length(rmNonOptimalFiles), "REMIND non_optimal_i.gdx files.\n")))
}
cat("Found", length(rm2pyFiles), "REMIND2PyPSAEUR_i.gdx files.\n")
cat("Found", length(pyResultsDirs), "PyPSA-EUR results directories.\n")
cat("Found", length(pyValidationDirs), "PyPSA-EUR validation directories.\n")
cat("Found", length(pyResourcesDirs) / length(years), "PyPSA-EUR resources directories.\n")
cat("Found", length(py2rmFiles), "PyPSAEUR2REMIND_i.gdx files.\n")

# Read coupled years from REMIND
years <- gdx::readGDX(rmFiles[1], "tPy32", restore_zeros = FALSE) %>%
  as.numeric()
# Remove attributes
attr(years, "gdxdata") <- NULL
attr(years, "description") <- NULL

# Read coupled regions from REMIND
regOrder <- c("DEU", "FRA", "EWN")
regions <- gdx::readGDX(rmFiles[1], "regPy32", restore_zeros = FALSE)
# Remove attributes
attr(regions, "gdxdata") <- NULL
attr(regions, "description") <- NULL
# Order regions
regions <- regions[match(regOrder, regions)]
# Remove NAs
regions <- regions[!is.na(regions)]

# Create region list (including all regions as a first entry)
if (length(regions) > 1) {
  regList <- list(
    regions
  )
  for (region in regions) {
    regList[[region]] <- region
  }
} else {
  regList <- list(regions)
}

# Unit conversions
twa2twh <- 8760
twa2mwh <- 8760 * 1e6
tC2tCO2 <- 44 / 12
trUSDpTWa2USDpMWh <- 1E12 / twa2mwh
trUSDpTW2USDpMW <- 1E6
```

---
subtitle: "`r scenario`"
---

```{r mappings, include = FALSE}
#techMapping <- read.csv(file.path(pyValidationDirs[1], "technology_mapping.csv"))

techMapping <- tribble(
  ~remind.eu, ~general, ~pypsa.eur,
  "ngcc", "CCGT", "CCGT",
  "ngccc", "CCGT", "CCGT",
  "gaschp", "CCGT", "CCGT",
  "ngt", "OCGT", "OCGT",
  "biochp", "biomass", "biomass",
  "bioigcc", "biomass", "biomass",
  "bioigccc", "biomass", "biomass",
  "igcc", "all_coal", "coal & lignite",
  "igccc", "all_coal", "coal & lignite",
  "pc", "all_coal", "coal & lignite",
  "coalchp", "all_coal", "coal & lignite",
  "fnrs", "nuclear", "nuclear",
  "tnrs", "nuclear", "nuclear",
  "dot", "oil", "oil",
  "wind", "wind_onshore", "onwind",
  "windoff", "wind_offshore", "offwind",
  "windoff", "wind_offshore", "offwind & offwind-ac & offwind-dc",
  "spv", "solar_pv", "solar & solar-rooftop & solar-utility",
  "spv", "solar_pv", "solar",
  "hydro", "hydro", "hydro",
  "hydro", "hydro", "ror",
  "hydro", "hydro", "PHS & hydro & ror"
)

# Create mapping from technology_group to general
techGroup2genTech <- c(
  "biomass" = "biomass",
  "coal & lignite" = "all_coal",
  "oil" = "oil",
  "electrolysis" = "electrolysis",
  "nuclear" = "nuclear",
  "CCGT" = "CCGT",
  "PHS & hydro & ror" = "hydro",
  "OCGT" = "OCGT",
  "solar & solar-rooftop & solar-utility" = "solar_pv",
  "onwind" = "wind_onshore",
  "offwind & offwind-ac & offwind-dc" = "wind_offshore"
)

# Create mapping from REMIND to General
rm2genTech <- setNames(techMapping$general, techMapping$remind.eu)
rm2genTech <- rm2genTech[!duplicated(names(rm2genTech))]

rm2genTech <- c(rm2genTech, c("elh2" = "electrolysis"))

# Create mapping from PyPSA-Eur to General
py2genTech <- setNames(techMapping$general, techMapping$pypsa.eur)
py2genTech <- py2genTech[!duplicated(names(py2genTech))]

py2genTech <- c(py2genTech, c("electrolysis" = "electrolysis",
                              "geothermal" = "geothermal",
                              "csp" = "csp",
                              "solar-utility" = "solar_pv",
                              "solar-rooftop" = "solar_pv",
                              "lignite" = "all_coal",
                              "coal" = "all_coal"))

# Create mapping from REMIND to PyPSA-Eur (for cost components)
# TODO: Remove
rm2pyTech <- c(
  "biochp" = "biomass",
  "bioigcc" = "biomass",
  "bioigccc" = "biomass",
  "ngcc" = "CCGT",
  "ngccc" = "CCGT",
  "gaschp" = "CCGT",
  "igcc" = "coal",
  "igccc" = "coal",
  "pc" = "coal",
  "coalchp" = "coal",
  "tnrs" = "nuclear",
  "fnrs" = "nuclear",
  "ngt" =  "OCGT",
  "windoff" = "offwind",
  "dot" = "oil",
  "wind" = "onwind",
  "hydro" = "hydro",
  "spv" = "solar",
  "elh2" = "electrolysis"
)

# Color mapping
colorsTech <- c(
  "electrolysis" = "#8E5FBE",
  "solar_pv" = "#ffcc00",
  "csp" = "#ff9900",
  "wind_onshore" = "#337fff",
  "wind_offshore" = "#334cff",
  "offwind" = "#334cff",  # Remove later
  "hydro" = "#191999",
  "geothermal" = "#C10505",
  "biomass" = "#005900",
  "CCGT" = "#999959",
  "OCGT" = "#e5e5b2",
  "oil" = "#663a00",
  "all_coal" = "#0c0c0c",
  "coal" = "#0c0c0c",  # Remove later
  "lignite" = "#392306",  # Remove later
  "nuclear" = "#ff33ff"
  )

# Pretty names
namesTech <- c(
  "electrolysis" = "Electrolysis",
  "solar_pv" = "Solar",
  "csp" = "CSP",
  "wind_onshore" = "Wind Onshore",
  "wind_offshore" = "Wind Offshore",
  "offwind" = "Wind Offshore",  # Remove later?
  "hydro" = "Hydro",
  "geothermal" = "Geothermal",
  "biomass" = "Biomass",
  "CCGT" = "CCGT",
  "OCGT" = "OCGT",
  "oil" = "Oil",
  "all_coal" = "Coal+Lignite",
  "coal" = "Coal",  # Remove later?
  "lignite" = "Lignite",  # Remove later?
  "nuclear" = "Nuclear")

```

```{r helpers, include = FALSE}
# This function reads in csv files in the PyPSA-Eur directory
# Expected path: <PyPSA-Eur folder>/i<iteration>/<some file>.csv
# (optionally also containing a y<year> folder)
readPyPSAcsv <- function(paths) {
  purrr::map_df(paths, ~{
    # Extract iteration from path
    iteration <- as.integer(str_extract(.x, "(?<=i)\\d{1,}(?=/)"))
    # Try to extract year from path
    year <- as.integer(str_extract(.x, "(?<=y)\\d{4}"))
    # Try to read csv file
    tryCatch(
      {
        df <- read.csv(.x, header = TRUE) %>%
          as_tibble() %>%
          mutate(iteration = iteration)
        # Conditionally add year column
        if (!("year" %in% names(df)) && !is.na(year)) {
          df <- df %>%
            mutate(year = year)
        }
        df
      },
      error = function(e) {
        cat("Error reading file:", .x, "\n")
        tibble() # Return an empty tibble in case of an error
      }
    )
  })
}

# This function reads in gdx files into tibbles
# rmFile: Path to gdx file
# gdxVar: Name of gdx variable to read
# columns: Named *vector* of columns to select and rename, must contain "value"
# colFilter: *List* of renamed columns and values to filter for
readGDXtibble <- function(rmFile, gdxVar, columns, colFilter,
                          restoreZeros = TRUE, field = "l", recalcUnit = 1) {
  # Read gdx file
  data <- gdx::readGDX(rmFile, gdxVar, restore_zeros = restoreZeros, field = field) %>%
    tibble::as_tibble(.name_repair = "unique")
  # If data is empty create tibble with columns from colFilter and column "value" filled with 0
  if (nrow(data) == 0) {
    data <- tibble::tibble(expand.grid(colFilter), value = 0)
  } else {
    data <- data %>%
      # Select desired columns and rename
      dplyr::select_at(names(columns), ~ columns) %>%
      # Filter columns according to colFilter
      dplyr::filter(dplyr::if_all(names(colFilter), ~ . %in% colFilter$.)) %>%
      # Multiply by recalcUnit
      dplyr::mutate(dplyr::across(columns["value"][[1]], ~ . * recalcUnit))
  }
  return(data)
}

# This function reads in multiple gdx files from REMIND
readREMINDgdx <- function(paths, gdxVar, columns, colFilter,
                          restoreZeros = TRUE, field = "l", recalcUnit = 1) {
  purrr::map_df(paths, ~{
    # Extract iteration from path.
    # Files may be named "fulldata_<iteration>.gdx" or
    # "non_optimal_<iteration>.gdx" or "REMIND2PyPSAEUR_<iteration>.gdx"
    iteration <- as.integer(str_extract(.x, "((?<=fulldata_)|(?<=non_optimal_)|(?<=REMIND2PyPSAEUR_))\\d{1,}(?=.gdx)"))
    readGDXtibble(.x, gdxVar, columns, colFilter, restoreZeros, field, recalcUnit) %>%
      mutate(iteration = iteration)
  })
}

# Helper function to extract unique values with a given tolerance
unique_tolerance <- function(x, tolerance = 1e-8) {
  x[!duplicated(round(x / tolerance))]
}

# Helper function to format ggplot subtitles
regSubtitle <- function(r) {
  paste(r, collapse = " + ")
}

# Helper function to return integer breaks for axis labels
integer_breaks <- function(n = 5, ...) {
  fxn <- function(x) {
    breaks <- floor(pretty(x, n, ...))
    names(breaks) <- attr(breaks, "labels")
    breaks
  }
  return(fxn)
}

```

# Coupled variables

This section includes plots of all variables that are exchanged between REMIND
and PyPSA-Eur.

## REMIND to PyPSA-Eur

This section includes variables that are transferred from REMIND to PyPSA-Eur (displayed as lines).
Values used by PyPSA-EUR are also retrieved to cross-check (displayed as points).

### Electricity load

```{r electricity load}
# Read REMIND data
dataLoadREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeDispNet",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  filter(iteration %in% pyIterations)

# Load PyPSAEUR electricity loads for cross-checking
dataLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_loads.csv")) %>%
  mutate(value = value / 1e6)  # Convert MWh to TWh

# Plot by year
pYear <- ggplot() +
  geom_line(data = dataLoadREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataLoadPyPSA, aes(x = year, y = value, color = region)) +
  scale_color_discrete(name = "Region") +
  labs(x = "Year", y = "Electricity load (TWh/a)") +
  scale_y_continuous(limit = c(0, NA)) +
  ggtitle("Electricity load by year") +
  facet_wrap(~ iteration)

print(pYear)

# Plot by iteration
pIter <- ggplot() +
  geom_line(data = dataLoadREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataLoadPyPSA, aes(x = iteration, y = value, color = region)) +
  scale_color_discrete(name = "Region") +
  labs(x = "Iteration", y = "Electricity load (TWh/a)") +
  scale_x_continuous(breaks = integer_breaks()) +
  scale_y_continuous(limit = c(0, NA)) +
  ggtitle("Electricity load by iteration") +
  facet_wrap(~ year)

print(pIter)
```

### Pre-investment capacities

Pre-investment capacities are used to initialize the PyPSA-Eur model. They are modelled as "free capacity" that PyPSA-Eur can build without incurring any CAPEX.

```{r pre-investment capacities, echo = FALSE, message = FALSE}
# Read REMIND data
dataPreInvCapAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_preInvCapAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_preInvCap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = 1e3) %>%   # TW to GW
  filter(technology != "hydro") %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(preInvCap = sum(p32_preInvCap)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

dataPreInvCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_preInvCap",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_preInvCap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = 1e3) %>%   # TW to GW
  filter(technology != "hydro") %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(preInvCap = sum(p32_preInvCap)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

# Read PyPSA-Eur data
dataPreInvCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "preinstalled_capacities.csv")) %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  rename(preInvCap = value) %>%
  rename(technology = carrier) %>%
  revalue.levels(technology = py2genTech) %>%
  order.levels(technology = names(colorsTech))

# Loop over regions
for (r in regList){

  dataPreInvCapAvgREMINDplot <- dataPreInvCapAvgREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(preInvCap = sum(preInvCap))

  dataPreInvCapREMINDplot <- dataPreInvCapREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(preInvCap = sum(preInvCap))

  dataPreInvCapPyPSAplot <- dataPreInvCapPyPSA %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(preInvCap = sum(preInvCap))

  pYear <- ggplot() +
    geom_line(data = dataPreInvCapAvgREMINDplot, aes(x = year, y = preInvCap, color = technology)) +
    geom_point(data = dataPreInvCapREMINDplot, aes(x = year, y = preInvCap, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataPreInvCapPyPSAplot, aes(x = year, y = preInvCap, color = technology), alpha = 0.5) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_shape_manual(name = NULL, values = c("Non-avg. value" = 4)) +
    labs(x = "Year", y = "Capacity (GW)") +
    ggtitle("Pre-investment capacities over years", regSubtitle(r))
  
  print(pYear + facet_wrap(~ iteration))

  pIteration <- ggplot() +
    geom_line(data = dataPreInvCapAvgREMINDplot, aes(x = iteration, y = preInvCap, color = technology)) +
    geom_point(data = dataPreInvCapREMINDplot, aes(x = iteration, y = preInvCap, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataPreInvCapPyPSAplot, aes(x = iteration, y = preInvCap, color = technology), alpha = 0.5) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_shape_manual(name = NULL, values = c("Non-avg. value" = 4)) +
    labs(x = "Iteration", y = "Capacity (GW)") +
    scale_x_continuous(breaks = integer_breaks()) +
    ggtitle("Pre-investment capacities over iterations", regSubtitle(r))

  print(pIteration + facet_wrap(~ year))

  print(pYear +
    facet_grid(technology ~ iteration,
               scales = "free",
               labeller = labeller(technology = namesTech)) +
    theme(legend.position = "none"))
  
  print(pIteration +
    facet_grid(technology ~ year,
               scales = "free",
               labeller = labeller(technology = namesTech)) +
    theme(legend.position = "none"))
}
```

### Specific capital costs w/ adjustment costs

Costs are the same across all regions as PyPSA-Eur doesn't have regionalised costs (yet). Costs from REMIND are hence aggregated.

```{r remind weights}
# Get weights used to aggregate costs

# Weights for generation technologies
dataWeightGenREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "p32_weightGen",
  columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "weight"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Weights for storage technologies
dataWeightStorREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "p32_weightStor",
  columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "weight"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Concatenate weights
dataWeightREMIND <- bind_rows(dataWeightGenREMIND, dataWeightStorREMIND) %>%
  filter(iteration %in% pyIterations)
```

```{r specific capital costs}
# REMIND
dataCapexREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_capCostwAdjCost",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_capCostwAdjCost"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTW2USDpMW) %>%
  filter(iteration %in% pyIterations)

# Calculated weighted average
dataCapexWeightedREMIND <- dataCapexREMIND %>%
  full_join(dataWeightREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(capex = sum(p32_capCostwAdjCost * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

# PyPSA-Eur
dataCapexPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "investment")

# Costs directly from REMIND
dataCapexPyPSArm <- dataCapexPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(technology, parameter, source, iteration, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique_tolerance(value)) %>%
  order.levels(technology = names(colorsTech))

# Costs passed from REMIND to PyPSA-Eur
pCapexYear <- ggplot() +
  geom_line(data = dataCapexWeightedREMIND, aes(x = year, y = capex, color = technology)) +
  geom_point(data = dataCapexPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     labels = namesTech) +
  labs(x = "Year", y = "Specific capital costs (USD/kW)") +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Specific capital costs (w/ adjustment costs) over years") +
  facet_wrap(~ iteration, scales = "free")

print(pCapexYear)

pCapexIter <- ggplot() +
  geom_line(data = dataCapexWeightedREMIND, aes(x = iteration, y = capex, color = technology)) +
  geom_point(data = dataCapexPyPSArm, aes(x = iteration, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     labels = namesTech) +
  labs(x = "Iteration", y = "Specific capital costs (USD/kW)") +
  scale_x_continuous(breaks = integer_breaks()) +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Specific capital costs (w/ adjustment costs) over iterations") +
  facet_wrap(~ year, scales = "free")

print(pCapexIter)

print(pCapexYear + facet_grid(technology ~ iteration,
                              scales = "free",
                              labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))

print(pCapexIter + facet_grid(technology ~ year,
                              scales = "free",
                              labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))

# Costs from REMIND scaled to similar PyPSA-Eur technologies
dataCapexPyPSArmpy <- dataCapexPyPSA %>%
  filter(source == "REMIND-EU and PyPSA-EUR") %>%
  mutate(techunit = paste0(technology, "\n(", unit, ")"))

if (nrow(dataCapexPyPSArmpy) > 0) {
  pCapexYearRmPy <- ggplot() +
    geom_line(data = dataCapexPyPSArmpy, aes(x = year,  y = value, color = techunit)) +
    scale_color_discrete(name = "Technology \n(scaled from REMIND)") +
    labs(x = "Year", y = "Specific capital costs (unit: see legend)") +
    ggtitle("Specific capital costs over years", "Scaled using similar REMIND-EU technologies") +
    facet_grid(technology ~ iteration, scales = "free")

  print(pCapexYearRmPy)
}

# Costs only from PyPSA-Eur
dataCapexPyPSApy <- dataCapexPyPSA %>%
  filter(!str_detect(source, "REMIND-EU"),
         value > 0) %>%
  mutate(techunit = paste0(technology, "\n(", unit, ")"))

if (nrow(dataCapexPyPSApy) > 0) {
  pCapexYearPy <- ggplot() +
    geom_line(data = dataCapexPyPSApy, aes(x = year,  y = value, color = techunit)) +
    scale_color_discrete(name = "Technology \n(only in PyPSA-Eur)") +
    labs(x = "Year", y = "Specific capital costs (unit: see legend)") +
    ggtitle("Specific capital costs over years", "Only in PyPSA-Eur") +
    facet_grid(technology ~ iteration, scales = "free")

  print(pCapexYearPy)
}
```

#### CAPEX and adjustment costs in REMIND

```{r capex and adjustment costs}

dataCapexTotREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_capCostwAdjCost",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_capCostwAdjCost"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = trUSDpTW2USDpMW)

dataCAPEXonlyREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_costTeCapital",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_costTeCapital"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = trUSDpTW2USDpMW)

dataCapexPlotREMIND <- dataCapexTotREMIND %>%
  left_join(dataCAPEXonlyREMIND, by = c("year", "region", "technology", "iteration")) %>%
  group_by(year, technology, iteration) %>%
  mutate(adjustment = p32_capCostwAdjCost - vm_costTeCapital) %>%
  # Use pivot_longer on adjustment and vm_costTeCapital
  tidyr::pivot_longer(cols = c("adjustment", "vm_costTeCapital"),
                      names_to = "char",
                      values_to = "value") %>%
  filter(iteration %in% pyIterations)

for (r in regions) {

  dataCapexPlotREMINDr <- dataCapexPlotREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration, char) %>%
    summarise(value = mean(value))

  p <- ggplot() +
    geom_bar(data = dataCapexPlotREMINDr,
             aes(x = year, y = value, fill = char),
             stat = "identity") +
    scale_fill_discrete(name = NULL,
                        labels = c("adjustment" = "Adjustment costs",
                                    "vm_costTeCapital" = "Capital costs")) +
    labs(x = "Year", y = "Specific capital costs (USD/kW)") +
    scale_y_continuous(labels = function(x) x / 1000) +
    ggtitle("Specific capital costs and adjustment costs over years", regSubtitle(r)) +
    facet_grid(technology ~ iteration, scales = "free")

  print(p)
}
```

### Fixed O&M costs

```{r fixed o&m costs}
# REMIND
dataFOMREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "variable", "all_te" = "technology", "value" = "value"),
    colFilter = list("region" = regions, "variable" = "omf", "technology" = names(rm2genTech))) %>%
  mutate(value = 100 * value) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(variable, technology) %>%
  # Values should be the same across years and iterations
  summarise(value = unique(value)) %>%
  # Add column for year
  tidyr::crossing(year = years) %>%
  order.levels(technology = names(colorsTech))

# PyPSA-Eur
dataFOMPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "FOM") %>%
  group_by(technology, parameter, source, year) %>%
  # Values should be the same across iterations
  summarise(value = unique_tolerance(value))

# Costs directly from REMIND
dataFOMPyPSArm <- dataFOMPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(technology, parameter, source, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique(value)) %>%
  order.levels(technology = names(colorsTech))

pFOMYear <- ggplot() +
  geom_line(data = dataFOMREMIND, aes(x = year, y = value, color = technology)) +
  geom_point(data = dataFOMPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     labels = namesTech) +
  labs(x = "Year", y = "Fixed O&M costs (%)") +
  ggtitle("Fixed O&M costs over years") +
  facet_wrap(~ technology,
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pFOMYear)

# Costs from REMIND scaled to similar PyPSA-Eur technologies
dataFOMPyPSArmpy <- dataFOMPyPSA %>%
  filter(source == "REMIND-EU and PyPSA-EUR")

if (nrow(dataFOMPyPSArmpy) > 0) {
  pFOMYearRmPy <- ggplot() +
    geom_line(data = dataFOMPyPSArmpy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology \n(scaled from REMIND)") +
    labs(x = "Year", y = "Fixed O&M costs (%)") +
    ggtitle("Fied O&M costs over years", "Scaled using similar REMIND-EU technologies") +
    facet_wrap(~ technology, scales = "free")

  print(pFOMYearRmPy)
}

# Costs only from PyPSA-Eur
dataFOMPyPSApy <- dataFOMPyPSA %>%
  filter(!str_detect(source, "REMIND-EU"),
         value > 0)

if (nrow(dataFOMPyPSApy) > 0) {
  pFOMYearPy <- ggplot() +
    geom_line(data = dataFOMPyPSApy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology \n(only in PyPSA-Eur)") +
    labs(x = "Year", y = "Fixed O&M costs (%)") +
    ggtitle("Fixed O&M costs over years", "Only in PyPSA-Eur") +
    facet_wrap(~ technology, scales = "free")

  print(pFOMYearPy)
}
```

### Lifetimes

```{r lifetimes}
# REMIND data
dataLifetimesREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "variable", "all_te" = "technology", "value" = "value"),
    colFilter = list("region" = regions, "variable" = "lifetime", "technology" = names(rm2genTech))) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(variable, technology) %>%
  # Values should be the same across years and iterations
  summarise(value = unique(value)) %>%
  # Add column for year
  tidyr::crossing(year = years) %>%
  order.levels(technology = names(colorsTech))

# PyPSA-Eur data
dataLifetimesPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "lifetime") %>%
  group_by(technology, parameter, source, year) %>%
  # Check for uniqueness with a given tolerance across iterations
  summarise(value = unique_tolerance(value))

# Lifetimes directly from REMIND
dataLifetimesPyPSArm <- dataLifetimesPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>% 
  group_by(technology, parameter, source, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique_tolerance(value)) %>%
  order.levels(technology = names(colorsTech))

pLifetimes <- ggplot() +
  geom_line(data = dataLifetimesREMIND, aes(x = year, y = value, color = technology)) +
  geom_point(data = dataLifetimesPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     labels = namesTech) +
  labs(x = "Year", y = "Lifetime (years)") +
  ggtitle("Lifetimes over years") +
  facet_wrap(~ technology,
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pLifetimes)
```

### Discount rates

```{r discount rates}
dataDiscountREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_discountRate",
    columns = c("ttot" = "year", "value" = "value"),
    colFilter = list("year" = years)) %>%
  filter(iteration %in% pyIterations)

dataDiscountPyPSA <- readPyPSAcsv(
    paths = file.path(pyResourcesDirs, "costs.csv")) %>%
    filter(parameter == "discount rate") %>%
  # Discount rate should be the same across technologies
  group_by(parameter, source, iteration, year) %>%
  summarise(value = unique(value))

pDiscountYear <- ggplot() +
  geom_line(data = dataDiscountREMIND, aes(x = year, y = value)) +
  geom_point(data = dataDiscountPyPSA, aes(x = year, y = value)) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(x = "Year", y = "Discount rate (%)") +
  ggtitle("Discount rates over years") +
  facet_wrap(~ iteration, scales = "free")

print(pDiscountYear)

pDiscountIter <- ggplot() +
  geom_line(data = dataDiscountREMIND, aes(x = iteration, y = value)) +
  geom_point(data = dataDiscountPyPSA, aes(x = iteration, y = value)) +
  labs(x = "Iteration", y = "Discount rate (%)") +
  scale_x_continuous(breaks = integer_breaks()) +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("Discount rates over iterations") +
  facet_wrap(~ year, scales = "free")

print(pDiscountIter)
```

### Variable O&M costs

```{r variable o&m costs}
# REMIND
dataVOMREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "variable", "all_te" = "technology", "value" = "vom"),
    colFilter = list("region" = regions, "variable" = "omv", "technology" = names(rm2genTech)),
    recalcUnit = trUSDpTWa2USDpMWh) %>%
    group_by(region, variable, technology) %>%
  # Remove if all values are 0
  filter(!all(vom == 0))

dataVOMWeightedREMIND <- dataVOMREMIND %>%
  left_join(dataWeightREMIND, by = c("region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(vom = sum(vom * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

# PyPSA-Eur
dataVOMPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "VOM")

# Costs directly from REMIND
dataVOMPyPSArm <- dataVOMPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  order.levels(technology = names(colorsTech))

pVOMTechYear <- ggplot() +
  geom_line(data = dataVOMWeightedREMIND, aes(x = year, y = vom, color = technology)) +
  geom_point(data = dataVOMPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech) +
  labs(x = "Year", y = "Variable O&M costs (USD/MWh)") +
  ggtitle("Variable O&M costs over years") +
  facet_grid(technology ~ iteration,
             scales = "free",
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pVOMTechYear)

pVOMTechIter <- ggplot() +
  geom_line(data = dataVOMWeightedREMIND, aes(x = iteration, y = vom, color = technology)) +
  geom_point(data = dataVOMPyPSArm, aes(x = iteration, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech) +
  labs(x = "Iteration", y = "Variable O&M costs (USD/MWh)") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Variable O&M costs over iterations") +
  facet_grid(technology ~ year,
             scales = "free",
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pVOMTechIter)

# Costs from REMIND scaled to similar PyPSA-Eur technologies
dataVOMPyPSArmpy <- dataVOMPyPSA %>%
  filter(source == "REMIND-EU and PyPSA-EUR")

if (nrow(dataVOMPyPSArmpy) > 0) {
  pVOMYearRmPy <- ggplot() +
    geom_line(data = dataVOMPyPSArmpy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(scaled from REMIND)") +
    labs(x = "Year", y = "Variable O&M costs (USD/MWh)") +
    ggtitle("Variable O&M costs over years", "Scaled using similar REMIND-EU technologies") +
    facet_grid(technology ~ iteration, scales = "free") +
    theme(legend.position = "none")

  print(pVOMYearRmPy)
}

# Cost only from PyPSA-Eur
dataVOMPyPSApy <- dataVOMPyPSA %>%
  filter(!str_detect(source, "REMIND-EU"),
         value > 0)

if (nrow(dataVOMPyPSApy) > 0) {
  pVOMYearPy <- ggplot() +
    geom_line(data = dataVOMPyPSApy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(only in PyPSA-Eur)") +
    labs(x = "Year", y = "Variable O&M costs (USD/MWh)") +
    ggtitle("Variable O&M costs over years", "Only in PyPSA-Eur") +
    facet_grid(technology ~ iteration, scales = "free") +
    theme(legend.position = "none")

  print(pVOMYearPy)
}
```

### Efficiencies

```{r efficiencies}

teReNoBio <- readGDX(rmFiles[1], "teReNoBio")

# Technologies for which eta is constant
dataEtaConvREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_eta_conv",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  filter(iteration %in% pyIterations)

# Technologies for which eta varies over time
dataEtaTimeREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataeta",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  filter(iteration %in% pyIterations)

# Weighted efficiencies
dataEtaWeightedREMIND <- dataEtaConvREMIND %>%
  bind_rows(dataEtaTimeREMIND) %>%
  # Special treament for nuclear: Transform efficiency from TWa/Mt_U to MWh/g_U
  mutate(eta = if_else(technology %in% c("tnrs", "fnrs"), eta*8760/1E6, eta)) %>%
  left_join(dataWeightREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(eta = sum(eta * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech))

# Read PyPSA-Eur data
dataEtaPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "efficiency")

# Efficiencies directly from REMIND
dataEtaPyPSArm <- dataEtaPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(technology, parameter, source, iteration, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique_tolerance(value)) %>%
  # TODO: Don't map fuel cell to electrolysis
  filter(technology %in% names(colorsTech)) %>%
  order.levels(technology = names(colorsTech))

pEtaTechYear <- ggplot() +
  geom_line(data = dataEtaWeightedREMIND, aes(x = year, y = eta, color = technology)) +
  geom_point(data = dataEtaPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech) +
  labs(x = "Year", y = "Efficiency") +
  ggtitle("Efficiencies over years") +
  facet_grid(technology ~ iteration, 
             scales = "free",
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pEtaTechYear)

pEtaTechIter <- ggplot() +
  geom_line(data = dataEtaWeightedREMIND, aes(x = iteration, y = eta, color = technology)) +
  geom_point(data = dataEtaPyPSArm, aes(x = iteration, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech) +
  labs(x = "Iteration", y = "Efficiency") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Efficiencies over iterations") +
  facet_grid(technology ~ year,
             scales = "free",
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pEtaTechIter)

# Efficiencies from REMIND scaled to similar PyPSA-Eur technologies
dataEtaPyPSArmpy <- dataEtaPyPSA %>%
  filter(source == "REMIND-EU and PyPSA-EUR")

if (nrow(dataEtaPyPSArmpy) > 0) {
  pEtaYearRmPy <- ggplot() +
    geom_line(data = dataEtaPyPSArmpy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(scaled from REMIND)") +
    labs(x = "Year", y = "Efficiency") +
    ggtitle("Efficiencies over years", "Scaled using similar REMIND-EU technologies") +
    facet_grid(technology ~ iteration)

  print(pEtaYearRmPy)
}

# Efficiencies only from PyPSA-Eur
dataEtaPyPSApy <- dataEtaPyPSA %>%
  filter(!str_detect(source, "REMIND-EU")) %>%
  group_by(technology, parameter, year) %>%
  # Values should be the same across iterations
  summarise(value = unique(value))

if (nrow(dataEtaPyPSApy) > 0) {
  pEtaYearPy <- ggplot() +
    geom_line(data = dataEtaPyPSApy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(only in PyPSA-Eur)") +
    labs(x = "Year", y = "Efficiency") +
    ggtitle("Efficiencies over years", "Only in PyPSA-Eur") +
    facet_wrap(~ technology)

  print(pEtaYearPy)
}
```

### Fuel costs

```{r fuel costs}

# Read pe2se mapping from REMIND
pe2seTech <- gdx::readGDX(rmFiles[1], "pe2se") %>%
  rename(pecarrier = all_enty,
         secarrier = all_enty1,
         technology = all_te) %>%
  filter(secarrier == "seel") %>%
  select(pecarrier, technology)

# Read REMIND data (averaged)
dataFuelCostsAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PEPriceAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "pecarrier", "value" = "p32_PEPriceAvg"),
    colFilter = list("year" = years, "region" = regions)) %>%
  full_join(pe2seTech, by = c("pecarrier"), relationship = "many-to-many") %>%
  full_join(dataEtaConvREMIND) %>%
  # Special treatment for nuclear: Costs in T$/Mt_U = $/gU -> don't convert
  mutate(p32_PEPriceAvg = case_when(pecarrier == "peur" ~ p32_PEPriceAvg,
                                    pecarrier != "peur" ~ p32_PEPriceAvg * trUSDpTWa2USDpMWh))

# Read REMIND data (true costs)
dataFuelCostsREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_PEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "pecarrier", "value" = "pm_PEPrice"),
    colFilter = list("year" = years, "region" = regions)) %>%
  full_join(pe2seTech, by = c("pecarrier"), relationship = "many-to-many") %>%
  full_join(dataEtaConvREMIND) %>%
  # Special treatment for nuclear: Costs in T$/Mt uranium, efficiency in TWa/Mt uranium
  mutate(pm_PEPrice = case_when(pecarrier == "peur" ~ pm_PEPrice,
                                pecarrier != "peur" ~ pm_PEPrice * trUSDpTWa2USDpMWh)
)

# Calculate weighted average fuel costs
dataFuelCostsAvgWeightedREMIND <- dataFuelCostsAvgREMIND %>%
  right_join(dataWeightGenREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(fuelCost = sum(p32_PEPriceAvg * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

# Calculate true average fuel costs
dataFuelCostsWeightedREMIND <- dataFuelCostsREMIND %>%
  right_join(dataWeightGenREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(fuelCost = sum(pm_PEPrice * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

# Remove technologies for which fuel costs are always zero in REMIND
zeroTech <- dataFuelCostsWeightedREMIND %>%
  group_by(technology) %>%
  filter(all(fuelCost == 0)) %>%
  pull(technology) %>%
  unique()

dataFuelCostsAvgWeightedREMIND <- dataFuelCostsAvgWeightedREMIND %>%
  filter(!(technology %in% zeroTech))

dataFuelCostsWeightedREMIND <- dataFuelCostsWeightedREMIND %>%
  filter(!technology %in% zeroTech)

# Read PyPSA-Eur data
dataFuelCostsPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "fuel")

# For gas create two technologies: CCGT and OCGT
dataFuelCostsPyPSA <- dataFuelCostsPyPSA %>%
  filter(technology != "gas") %>%
  bind_rows(
    filter(dataFuelCostsPyPSA, technology == "gas") %>%
      mutate(technology = "CCGT"),
    filter(dataFuelCostsPyPSA, technology == "gas") %>%
      mutate(technology = "OCGT")
  )

# Fuel costs directly from REMIND
dataFuelCostsPyPSArm <- dataFuelCostsPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(technology, parameter, source, iteration, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique(value)) %>%
  order.levels(technology = names(colorsTech))

pFuelCostsYear <- ggplot() +
  geom_line(data = dataFuelCostsAvgWeightedREMIND, aes(x = year, y = fuelCost, color = technology)) +
  geom_point(data = dataFuelCostsWeightedREMIND, aes(x = year, y = fuelCost, color = technology, shape = "Non-avg. value")) +
  scale_shape_manual(name = NULL,
                     values = c("Non-avg. value" = 4)) +
  geom_point(data = dataFuelCostsPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     labels = namesTech) +
  scale_y_continuous(limits = c(0, 150)) +
  labs(x = "Year", y = "Fuel costs (USD/MWh)") +
  ggtitle("Fuel costs over years", "Averaged over iterations")

print(pFuelCostsYear + facet_wrap(~ iteration))

pFuelCostsIter <- ggplot() +
  geom_line(data = dataFuelCostsAvgWeightedREMIND, aes(x = iteration, y = fuelCost, color = technology)) +
  geom_point(data = dataFuelCostsWeightedREMIND, aes(x = iteration, y = fuelCost, color = technology, shape = "Non-avg. value")) +
  scale_shape_manual(name = NULL,
                     values = c("Non-avg. value" = 4)) +
  geom_point(data = dataFuelCostsPyPSArm, aes(x = iteration, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     labels = namesTech) +
  scale_y_continuous(limits = c(0, 150)) +
  labs(x = "Iteration", y = "Fuel costs (USD/MWh)") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Fuel costs over iterations", "Averaged over iterations")

print(pFuelCostsIter + facet_wrap(~ year))

print(pFuelCostsYear +
  facet_grid(technology ~ iteration,
              scales = "free",
              labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none"))

print(pFuelCostsIter +
  facet_grid(technology ~ year,
              scales = "free",
              labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none"))

# Fuel costs from REMIND scaled to similar PyPSA-Eur technologies
dataFuelCostsPyPSArmpy <- dataFuelCostsPyPSA %>%
  filter(source == "REMIND-EU and PyPSA-EUR")

if (nrow(dataFuelCostsPyPSArmpy) > 0) {
  pFuelCostsYearRmPy <- ggplot() +
    geom_line(data = dataFuelCostsPyPSArmpy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(scaled from REMIND)") +
    labs(x = "Year", y = "Fuel costs (USD/MWh)") +
    ggtitle("Fuel costs over years", "Scaled using similar REMIND-EU technologies") +
    facet_grid(technology ~ iteration,
               scales = "free")

  print(pFuelCostsYearRmPy)
}

# Fuel costs only from PyPSA-Eur
dataFuelCostsPyPSApy <- dataFuelCostsPyPSA %>%
  filter(!str_detect(source, "REMIND-EU"),
         value > 0)

if (nrow(dataFuelCostsPyPSApy) > 0) {
  pFuelCostsYearPy <- ggplot() +
    geom_line(data = dataFuelCostsPyPSApy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(only in PyPSA-Eur)") +
    labs(x = "Year", y = "Fuel costs (USD/MWh)") +
    ggtitle("Fuel costs over years", "Only in PyPSA-Eur") +
    facet_grid(technology ~ iteration,
               scales = "free")

  print(pFuelCostsYearPy)
}
```

### CO2 intensity

```{r co2 intensity}

# Read REMIND data
dataCO2intREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "fm_dataemiglob",
    columns = c("all_enty" = "pecarrier", "all_enty1" = "secarrier", "all_te" = "technology", "all_enty2" = "gas", "value" = "co2int"),
    colFilter = list("secarrier" = "seel", "gas" = "co2", technology = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = 1E9 * tC2tCO2 / twa2mwh) %>%
  group_by(technology) %>%
  summarise(co2int = unique(co2int))

dataCO2intWeightedREMIND <- dataCO2intREMIND %>%
  right_join(dataWeightREMIND, by = c("technology")) %>%
  # Replace biochp and bioigcc with zero
  mutate(co2int = if_else(technology %in% c("biochp", "bioigcc"), 0, co2int)) %>%
  group_by(technology) %>%
  filter(!is.na(co2int)) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(co2int = sum(co2int * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

# PyPSA-Eur data
dataCO2intPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "CO2 intensity",
         # Filter gas because CCGT and OCGT already there
         technology != "gas")

# CO2 intensity directly from REMIND
dataCO2intPyPSArm <- dataCO2intPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(technology, parameter, source, iteration, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique(value)) %>%
  order.levels(technology = names(colorsTech))

pCO2intYear <- ggplot() +
  geom_line(data = dataCO2intWeightedREMIND, aes(x = year, y = co2int, color = technology)) +
  geom_point(data = dataCO2intPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     breaks = namesTech) +
  labs(x = "Year", y = "CO2 intensity (tCO2/MWh)") +
  ggtitle("CO2 intensity over years") +
  facet_grid(technology ~ iteration,
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pCO2intYear)

pCO2intIter <- ggplot() +
  geom_line(data = dataCO2intWeightedREMIND, aes(x = iteration, y = co2int, color = technology)) +
  geom_point(data = dataCO2intPyPSArm, aes(x = iteration, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     breaks = namesTech) +
  labs(x = "Iteration", y = "CO2 intensity (tCO2/MWh)") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("CO2 intensity over iterations") +
  facet_grid(technology ~ year,
             labeller = labeller(technology = namesTech)) +
  theme(legend.position = "none")

print(pCO2intIter)

# CO2 intensity from REMIND scaled to similar PyPSA-Eur technologies
dataCO2intPyPSArmpy <- dataCO2intPyPSA %>%
  filter(source == "REMIND-EU and PyPSA-EUR")

if (nrow(dataCO2intPyPSArmpy) > 0) {
  pCO2intYearRmPy <- ggplot() +
    geom_line(data = dataCO2intPyPSArmpy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(scaled from REMIND)") +
    labs(x = "Year", y = "CO2 intensity (tCO2/MWh)") +
    ggtitle("CO2 intensity over years", "Scaled using similar REMIND-EU technologies") +
    facet_grid(technology ~ iteration)

  print(pCO2intYearRmPy)
}

# CO2 intensity only from PyPSA-Eur
dataCO2intPyPSApy <- dataCO2intPyPSA %>%
  filter(!str_detect(source, "REMIND-EU"),
         value > 0)

if (nrow(dataCO2intPyPSApy) > 0) {
  pCO2intYearPy <- ggplot() +
    geom_line(data = dataCO2intPyPSApy, aes(x = year,  y = value, color = technology)) +
    scale_color_discrete(name = "Technology\n(only in PyPSA-Eur)") +
    labs(x = "Year", y = "CO2 intensity (tCO2/MWh)") +
    ggtitle("CO2 intensity over years", "Only in PyPSA-Eur") +
    facet_grid(technology ~ iteration)

  print(pCO2intYearPy)
}
```

### CO2 prices

```{r co2 price}
# REMIND data
dataCO2PriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p_priceCO2",
    columns = c("tall" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = TRUE,
    recalcUnit = 1 / tC2tCO2
  ) %>%
  filter(iteration %in% pyIterations)

# PyPSA data
dataCO2PricePyPSA <- readPyPSAcsv(
    paths = file.path(pyResultsDirs, "co2_price_scenarios.csv")) %>% 
  # Extract the CO2 price from the opts columns which starts with Ep followed by a number of format 0.0
  mutate(value = as.numeric(str_extract(opts, "(?<=Ep)\\d+\\.\\d{1,2}")))

# Plot by year
pCO2PriceYear <- ggplot() +
  geom_line(data = dataCO2PriceREMIND, aes(x = year, y = value, color = region)) +
  scale_color_discrete(name = "REMIND region") +
  new_scale_color() +
  geom_point(data = dataCO2PricePyPSA, aes(x = year, y = value, color = "All regions")) +
  scale_color_discrete(name = "PyPSA region") +
  labs(x = "Year", y = "CO2 price (USD/tCO2)") +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("CO2 price over years") +
  facet_wrap(~ iteration)

print(pCO2PriceYear)

# Plot by iteration
pCO2PriceIter <- ggplot() +
  geom_line(data = dataCO2PriceREMIND, aes(x = iteration, y = value, color = region)) +
  scale_color_discrete(name = "REMIND region") +
  new_scale_color() +
  geom_point(data = dataCO2PricePyPSA, aes(x = iteration, y = value, color = "All regions")) +
  scale_color_discrete(name = "PyPSA region") +
  labs(x = "Iteration", y = "CO2 price (USD/tCO2)") +
  scale_x_continuous(breaks = integer_breaks()) +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("CO2 price over iterations") +
  facet_wrap(~ year)

print(pCO2PriceIter)
```

### Hydro capacities and availability factors

```{r hydro capacities and capacity factors}

# Hydro capacities
dataHydroCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_hydroCap",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE,
    recalcUnit = 1E3) %>%  # TW to GW
  filter(iteration %in% pyIterations)

dataHydroCapPyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "optimal_capacities.csv")) %>%
  filter(carrier == "PHS & hydro & ror",
         type == "Generator") %>%
  mutate(value = value / 1E3)  # MW to GW

# Plot by year
pHydroCapYear <- ggplot() +
  geom_line(data = dataHydroCapREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataHydroCapPyPSA, aes(x = year, y = value, color = region)) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(x = "Year", y = "Capacity (GW)") +
  ggtitle("Hydro (dams & ror) capacity over years") +
  facet_wrap(~ iteration)

print(pHydroCapYear)

# Plot by iteration
pHydroCapIter <- ggplot() +
  geom_line(data = dataHydroCapREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataHydroCapPyPSA, aes(x = iteration, y = value, color = region)) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(x = "Iteration", y = "Capacity (GW)") +
  ggtitle("Hydro (dams & ror) capacity over iterations") +
  facet_wrap(~ year)

print(pHydroCapIter)

# Hydro generation
dataHydroGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_hydroGen",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE) %>%
  filter(iteration %in% pyIterations)

# Calculate availability factor
dataHydroAvailREMIND <- dataHydroGenREMIND %>%
  left_join(dataHydroCapREMIND, by = c("year", "region", "iteration")) %>%
  mutate(value = 1E3 * value.x / value.y)

dataHydroAvailPyPSa <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "availability_factors.csv")) %>%
  filter(carrier == "hydro")

pHydroAvailYear <- ggplot() +
  geom_line(data = dataHydroAvailREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataHydroAvailPyPSa, aes(x = year, y = value, color = region)) +
  scale_y_continuous(limits = c(0, 1)) +
  labs(x = "Year", y = "Availability factor") +
  ggtitle("Hydro (dams & ror) availability factor over years") +
  facet_wrap(~ iteration)

print(pHydroAvailYear)

pHydroAvailIter <- ggplot() +
  geom_line(data = dataHydroAvailREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataHydroAvailPyPSa, aes(x = iteration, y = value, color = region)) +
  scale_y_continuous(limits = c(0, 1)) +
  labs(x = "Iteration", y = "Availability factor") +
  ggtitle("Hydro (dams & ror) availability factor over iterations") +
  facet_wrap(~ year)

print(pHydroAvailIter)

```

## PyPSA-Eur to REMIND

This section includes variables that are transferred from PyPSA-Eur to REMIND (displayed as points).
Values used by REMIND are also retrieved to cross-check (displayed as lines).

### Capacity factors

The following plots show the capacity factor.

ToDo: This doesn't work properly for the case of "all regions" yet as the PyPSA capacity factors cannot simply be aggregated over regions.

```{r capacity factors}
# REMIND capacity factors (pre-factor based)
dataCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_cap",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
    restoreZeros = FALSE) %>%
  select(-grade)

dataUsableSeTeDispREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

# REMIND averaged capacity factors
dataCapFacAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PyPSA_CFAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PyPSA_CFAvg"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  # Increment iteration by 1 because this value is only available for the next iteration
  mutate(iteration = iteration + 1) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(p32_PyPSA_CFAvg = unique(p32_PyPSA_CFAvg))

# PyPSA-Eur capacity factors
dataCapfacPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "capacity_factors.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value))

for (r in regList){

  dataCapfacREMINDplot <- full_join(dataCapREMIND, dataUsableSeTeDispREMIND) %>%
    filter(region %in% r,
           vm_cap != 0) %>%
    group_by(year, technology, iteration) %>%
    # First calculate capacity factor for each REMIND technology across all regions
    summarise(capfac = sum(v32_usableSeTeDisp) / sum(vm_cap),
              v32_usableSeTeDispRegSum = sum(v32_usableSeTeDisp)) %>%
    revalue.levels(technology = rm2genTech) %>%
    group_by(year, technology, iteration) %>%
    # Second calculate weighted capacity factor for general technologies
    summarise(capfac = sum(capfac * v32_usableSeTeDispRegSum) / sum(v32_usableSeTeDispRegSum)) %>%
    quitte::order.levels(technology = names(namesTech)) %>%
    rename(value = capfac)

  dataCapfacAvgREMINDplot <- dataCapFacAvgREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(p32_PyPSA_CFAvg = mean(p32_PyPSA_CFAvg)) %>%
    quitte::order.levels(technology = names(namesTech))

  dataCapfacPyPSAplot <- dataCapfacPyPSA %>%
    filter(region %in% r,
           value != 0) %>%
    group_by(year, carrier, iteration) %>%
    rename(technology = carrier) %>%
    summarise(value = mean(value)) %>%  # ToDO: This is not exactly correct for all regions
    quitte::order.levels(technology = names(namesTech))

  # Plot by year
  pCapfacYear <- ggplot() +
    geom_line(data = dataCapfacREMINDplot, aes(x = year, y = value, color = technology)) +
    geom_point(data = dataCapfacPyPSAplot, aes(x = year, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataCapfacAvgREMINDplot, aes(x = year, y = p32_PyPSA_CFAvg, color = technology), alpha = 0.5) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Capacity factor") +
    scale_y_continuous(limits = c(0, 1)) +
    ggtitle("Capacity factors over years, averaged over iterations", regSubtitle(r))

  print(pCapfacYear + facet_wrap(~ iteration))

  # Plot by iteration
  pCapfacIter <- ggplot() +
    geom_line(data = dataCapfacREMINDplot, aes(x = iteration, y = value, color = technology)) +
    geom_point(data = dataCapfacPyPSAplot, aes(x = iteration, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataCapfacAvgREMINDplot, aes(x = iteration, y = p32_PyPSA_CFAvg, color = technology), alpha = 0.5) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Iteration", y = "Capacity factor") +
    scale_x_continuous(breaks = integer_breaks()) +
    scale_y_continuous(limits = c(0, 1)) +
    ggtitle("Capacity factors over iterations, averaged over iterations", regSubtitle(r))

  print(pCapfacIter + facet_wrap(~ year))

  print(pCapfacYear + facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))
  
  print(pCapfacIter + facet_grid(technology ~ year, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))

}
```

### Curtailments

Work in progress. Not yet coupled from PyPSA-Eur to REMIND.

```{r curtailments}
# REMIND
tePyVRE32 <- gdx::readGDX(rmFiles[1], "tePyVRE32", restore_zeros = FALSE)

dataCurtailmentREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_storloss",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "v32_storloss"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  filter(technology %in% tePyVRE32) %>%
  revalue.levels(technology = rm2genTech) %>%
  quitte::order.levels(technology = names(colorsTech))

# PyPSA-Eur
dataCurtailmentPyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "curtailments.csv")) %>%
  filter(value != 0) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  quitte::order.levels(carrier = names(namesTech)) %>%
  mutate(value = value / 1e6) %>%  # Convert MWh to TWh
  rename(technology = carrier)

for (r in regList) {

  dataCurtailmentplotREMIND <- dataCurtailmentREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(v32_storloss = sum(v32_storloss))

  dataCurtailmentplotPyPSA <- dataCurtailmentPyPSA %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(value = sum(value))

  pCurtailmentYear <- ggplot() +
    geom_line(data = dataCurtailmentplotREMIND, aes(x = year, y = v32_storloss, color = technology)) +
    geom_point(data = dataCurtailmentplotPyPSA, aes(x = year, y = value, color = technology)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Curtailment (TWh/yr)") +
    ggtitle("Curtailment over years", regSubtitle(r)) +
    facet_wrap(~ iteration)

  print(pCurtailmentYear)

  pCurtailmentIter <- ggplot() +
    geom_line(data = dataCurtailmentplotREMIND, aes(x = iteration, y = v32_storloss, color = technology)) +
    geom_point(data = dataCurtailmentplotPyPSA, aes(x = iteration, y = value, color = technology)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Curtailment (TWh/yr)") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Curtailment over iterations", regSubtitle(r)) +
    facet_wrap(~ year)

  print(pCurtailmentIter)
}
```

### Markups (supply side)

Markups and markdowns are read into REMIND from PyPSA-Eur. Markup = Average market value - Average electricity price

```{r markups}
# REMIND (pre-factor based)
dataMarkupREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_PyPSAMarkup",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh)

dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  select(-secarrier)

dataMarkupWeightedREMIND <- dataMarkupREMIND %>%
  right_join(dataGenREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(namesTech))

# PyPSA-Eur
dataMarketValuePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "market_values.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  quitte::order.levels(carrier = names(namesTech))

dataElecPricePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "load_prices.csv")) %>%
  filter(carrier == "AC") %>%
  select(!carrier) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1)

dataMarkupPyPSA <- dataMarketValuePyPSA %>%
  left_join(dataElecPricePyPSA, by = c("year", "region", "iteration")) %>%
  mutate(value = value.x - value.y) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  rename(technology = carrier) %>%
  order.levels(technology = names(namesTech))

# Average markup REMIND
dataMarketValueAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PyPSA_MVAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PyPSA_MVAvg"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  # Increment iteration by 1 because this value is only available for the next iteration
  mutate(iteration = iteration + 1) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(p32_PyPSA_MVAvg = unique(p32_PyPSA_MVAvg))

# Average electricity price REMIND
dataElecPriceAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PyPSA_LoadPriceAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "carrierPy32" = "carrier", "value" = "p32_PyPSA_LoadPriceAvg"),
    colFilter = list("year" = years, "region" = regions, "carrier" = "AC"),
    restoreZeros = FALSE) %>%
  # Increment iteration by 1 because this value is only available for the next iteration
  mutate(iteration = iteration + 1) %>%
  select(-carrier)

dataMarkupAvgREMIND <- dataMarketValueAvgREMIND %>%
  right_join(dataElecPriceAvgREMIND, by = c("year", "region", "iteration")) %>%
  mutate(p32_PyPSA_MarkupAvg = p32_PyPSA_MVAvg - p32_PyPSA_LoadPriceAvg)

for (r in regions) {

  dataMarkupPlotREMIND <- dataMarkupWeightedREMIND %>%
    filter(region == r)

  dataMarkupPlotPyPSA <- dataMarkupPyPSA %>%
    filter(region == r)

  dataMarkupAvgPlotREMIND <- dataMarkupAvgREMIND %>%
    filter(region == r)

  pMarkupYear <- ggplot() +
    geom_line(data = dataMarkupPlotREMIND, aes(x = year, y = value, color = technology)) +
    geom_point(data = dataMarkupPlotPyPSA, aes(x = year, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataMarkupAvgPlotREMIND, aes(x = year, y = p32_PyPSA_MarkupAvg, color = technology), alpha = 0.5) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Markup ($/MWh)") +
    ggtitle("Markups over years, averaged over iterations", regSubtitle(r))

  print(pMarkupYear + facet_wrap(~ iteration, scales = "free"))

  pMarkUpIter <- ggplot() +
    geom_line(data = dataMarkupPlotREMIND, aes(x = iteration, y = value, color = technology)) +
    geom_point(data = dataMarkupPlotPyPSA, aes(x = iteration, y = value, color = technology, shape = "Non-avg. value")) +
    geom_point(data = dataMarkupAvgREMIND, aes(x = iteration, y = p32_PyPSA_MarkupAvg, color = technology), alpha = 0.5) +
    scale_shape_manual(name = NULL,
                       values = c("Non-avg. value" = 4)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Iteration", y = "Markup ($/MWh)") +
    scale_x_continuous(breaks = integer_breaks()) +
    ggtitle("Markups over iterations", regSubtitle(r))

  print(pMarkUpIter + facet_wrap(~ year, scales = "free"))

  print(pMarkupYear +
        facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))

  print(pMarkUpIter +
        facet_grid(technology ~ year, scales = "free", labeller = labeller(technology = namesTech)) +
        theme(legend.position = "none"))
}
```

### Markup tax revenue (supply side)

Markups are implemented as a tax/subsidy in REMIND in order to manipulate a variable that is usually an outcome (Lagrangian multiplier of the optimisation) and not an input.

Here we look at the tax revenue from markups, which should approach zero over iterations.

```{r markup tax revenue}
# REMIND
dataMarkUpRevenue <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v21_taxrevPyPSAMarkup",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE,
    recalcUnit = -1E6)  # T$/yr to Million $/yr

for (r in regList) {
  
  dataMarkUpRevenuePlot <- dataMarkUpRevenue %>%
    filter(region %in% r) %>%
    group_by(year, iteration) %>%
    summarise(value = sum(value))

  pMarkUpRevenue <- ggplot() +
    geom_line(data = dataMarkUpRevenuePlot, aes(x = year, y = value)) +
    labs(x = "Year", y = "Markup revenue (Million $/yr)") +
    ggtitle("Markup revenue over years (supply side)", regSubtitle(r)) +
    facet_wrap(~ iteration)

  print(pMarkUpRevenue)
}
```

### Markups (demand side)

### Markup tax revenue (demand side)

### Peak residual load

Relative peak residual load is passed from PyPSA-Eur to REMIND. REMIND can go higher than the PyPSA-Eur value, but not lower.

```{r peak residual load relative}
# REMIND data (pre-factor based)
#dataCapREMIND <- readREMINDgdx(
#    paths = rmFiles,
#    gdxVar = "vm_cap",
#    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
#    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
#    restoreZeros = FALSE)

tePyDisp32 <- gdx::readGDX(rmFiles[1], "tePyDisp32", restore_zeros = FALSE)

dataDispCapSumREMIND <- dataCapREMIND %>%
  filter(technology %in% tePyDisp32) %>%
  group_by(year, region, iteration) %>%
  summarise(dispCapSum = sum(vm_cap))

dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeDispNet",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "v32_usableSeDispNet"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE)

dataPeakResLoadREMIND <- dataDispCapSumREMIND %>%
  left_join(dataGenREMIND, by = c("year", "region", "iteration")) %>%
  mutate(peakResLoad = dispCapSum / v32_usableSeDispNet)

# PyPSA csv contains both absolute and relative
dataPeakResLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "peak_residual_loads.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1)

pPeakResLoadYear <- ggplot() +
  geom_line(data = dataPeakResLoadREMIND, aes(x = year, y = peakResLoad, color = region)) +
  geom_point(data = dataPeakResLoadPyPSA, aes(x = year, y = relative, color = region)) +
  labs(x = "Year", y = "Relative peak residual load") +
  ggtitle("Relative peak residual load over years") +
  facet_wrap(~ iteration, scales = "free")

print(pPeakResLoadYear)

pPeakResLoadIter <- ggplot() +
  geom_line(data = dataPeakResLoadREMIND, aes(x = iteration, y = peakResLoad, color = region)) +
  geom_point(data = dataPeakResLoadPyPSA, aes(x = iteration, y = relative, color = region)) +
  labs(x = "Iteration", y = "Relative peak residual load") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Relative peak residual load over iterations") +
  facet_wrap(~ year, scales = "free")

print(pPeakResLoadIter)

```

```{r peak residual load absolute}

pPeakResLoadAbsYear <- ggplot() +
  geom_line(data = dataPeakResLoadPyPSA, aes(x = year, y = absolute, color = region)) +
  labs(x = "Year", y = "Peak residual load (GW)") +
  scale_y_continuous(labels = function(x) x / 1000) +
  ggtitle("Peak residual load over years in PyPSA-Eur", "Not directly coupled with REMIND") +
  facet_wrap(~ iteration)

print(pPeakResLoadAbsYear)

```

### Electricity trade

```{r electricity trade}
if (isTRUE(cfg$gms$c32_pypsa_trade == "on")) {
  dataImportREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_Mport",
    columns = c("tall" = "year", "all_regi" = "region", "all_enty" = "enty", "value" = "vm_Mport"),
    colFilter = list("year" = years, "region" = regions, "enty" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = twa2twh)

  dataExportREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_Xport",
    columns = c("tall" = "year", "all_regi" = "region", "all_enty" = "enty", "value" = "vm_Xport"),
    colFilter = list("year" = years, "region" = regions, "enty" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = twa2twh)

  dataTradePyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "crossborder_flows.csv")) %>%
    # Increment iteration by 1 to match REMIND
    mutate(iteration = iteration + 1)

  dataImportPyPSA <- dataTradePyPSA %>%
    group_by(year, to, iteration) %>%
    summarise(value = sum(exports) / 1E6) %>%
    rename(region = to)

  dataExportPyPSA <- dataTradePyPSA %>%
    group_by(year, from, iteration) %>%
    summarise(value = sum(exports) / 1E6) %>%
    rename(region = from)

  pImport <- ggplot() +
    geom_line(data = dataImportREMIND, aes(x = year, y = vm_Mport, color = region)) +
    geom_point(data = dataImportPyPSA, aes(x = year, y = value, color = region)) +
    labs(x = "Year", y = "Electricity trade (TWh/yr)") +
    ggtitle("Electricity imports over years") +
    facet_wrap(~ iteration, scales = "free")

  print(pImport)

  pImportIter <- ggplot() +
    geom_line(data = dataImportREMIND, aes(x = iteration, y = vm_Mport, color = region)) +
    geom_point(data = dataImportPyPSA, aes(x = iteration, y = value, color = region)) +
    labs(x = "Iteration", y = "Electricity trade (TWh/yr)") +
    scale_x_continuous(breaks = integer_breaks()) +
    ggtitle("Electricity imports over iterations") +
    facet_wrap(~ year, scales = "free")

  print(pImportIter)

  pExport <- ggplot() +
    geom_line(data = dataExportREMIND, aes(x = year, y = vm_Xport, color = region)) +
    geom_point(data = dataExportPyPSA, aes(x = year, y = value, color = region)) +
    labs(x = "Year", y = "Electricity trade (TWh/yr)") +
    ggtitle("Electricity exports over years") +
    facet_wrap(~ iteration, scales = "free")

  print(pExport)

  pExportIter <- ggplot() +
    geom_line(data = dataExportREMIND, aes(x = iteration, y = vm_Xport, color = region)) +
    geom_point(data = dataExportPyPSA, aes(x = iteration, y = value, color = region)) +
    labs(x = "Iteration", y = "Electricity trade (TWh/yr)") +
    scale_x_continuous(breaks = integer_breaks()) +
    ggtitle("Electricity exports over iterations") +
    facet_wrap(~ year, scales = "free")

  print(pExportIter)
}
```

#### Net electricity trade

```{r net electricity trade}
if (isTRUE(cfg$gms$c32_pypsa_trade == "on")) {
  for (r in regions) {
    dataImportPyPSAr <- dataTradePyPSA %>%
      filter(to %in% r) %>%
      mutate(value = exports / 1E6) %>%
      select(year, from, iteration, value)

    dataExportPyPSAr <- dataTradePyPSA %>%
      filter(from %in% r) %>%
      mutate(value = -exports / 1E6) %>%
      select(year, to, iteration, value)

    dataNetPyPSAr <- dataTradePyPSA %>%
      filter(from %in% r | to %in% r) %>%
      mutate(exports = ifelse(from %in% r, -exports, exports)) %>%
      group_by(year, iteration) %>%
      summarise(value = sum(exports) / 1E6) 

    pYear <- ggplot() + 
      geom_bar(data = dataImportPyPSAr, aes(x = year, y = value, fill = from), stat = "identity") +
      geom_bar(data = dataExportPyPSAr, aes(x = year, y = value, fill = to), stat = "identity") +
      scale_fill_discrete(name = "To/From") +
      geom_line(data = dataNetPyPSAr, aes(x = year, y = value, color = "Net")) +
      scale_color_manual(name = NULL, values = "black") +
      labs(x = "Year", y = "Imports (TWh/yr)") +
      ggtitle("Net electricity imports over years", regSubtitle(r)) +
      facet_wrap(~ iteration, scales = "free")

    print(pYear)

    pIter <- ggplot() + 
      geom_bar(data = dataImportPyPSAr, aes(x = iteration, y = value, fill = from), stat = "identity") +
      geom_bar(data = dataExportPyPSAr, aes(x = iteration, y = value, fill = to), stat = "identity") +
      scale_fill_discrete(name = "To/From") +
      geom_line(data = dataNetPyPSAr, aes(x = iteration, y = value, color = "Net")) +
      scale_color_manual(name = NULL, values = "black") +
      labs(x = "Iteration", y = "Imports (TWh/yr)") +
      scale_x_continuous(breaks = integer_breaks()) +
      ggtitle("Net electricity imports over iterations", regSubtitle(r)) +
      facet_wrap(~ year, scales = "free")

    print(pIter)
  }
}

```

### Electricity trade price

```{r electricity trade price}
if (isTRUE(cfg$gms$c32_pypsa_trade == "on")) {
dataImportPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_MPortsPrice",
    columns = c("tall" = "year", "all_regi" = "region", "tradeSe" = "tradeSe", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "tradeSe" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh) %>%
  select(!tradeSe)

dataImportPricePyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "crossborder_prices_import.csv")) %>%
    # Increment iteration by 1 to match REMIND
    mutate(iteration = iteration + 1)

dataExportPricePyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "crossborder_prices_export.csv")) %>%
    # Increment iteration by 1 to match REMIND
    mutate(iteration = iteration + 1)

dataTradePyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "crossborder_flows.csv")) %>%
    # Increment iteration by 1 to match REMIND
    mutate(iteration = iteration + 1)

dataImportPricePyPSA <- full_join(dataImportPricePyPSA, dataTradePyPSA, by = c("year", "iteration", "from", "to")) %>%
  group_by(year, to, iteration) %>%
  summarise(priceImport = sum(price*exports)/sum(exports))

dataExportPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_XPortsPrice",
    columns = c("tall" = "year", "all_regi" = "region", "tradeSe" = "tradeSe", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "tradeSe" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh) %>%
  select(!tradeSe)

dataExportPricePyPSA <- full_join(dataExportPricePyPSA, dataTradePyPSA, by = c("year", "iteration", "from", "to")) %>%
  group_by(year, from, iteration) %>%
  summarise(priceExport = sum(price*exports)/sum(exports))

pImportPrice <- ggplot() +
  geom_line(data = dataImportPriceREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataImportPricePyPSA, aes(x = year, y = priceImport, color = to)) +
  labs(x = "Year", y = "Electricity trade price ($/MWh)") +
  ggtitle("Electricity import prices over years") +
  facet_wrap(~ iteration, scales = "free")

print(pImportPrice)

pImportPriceIter <- ggplot() +
  geom_line(data = dataImportPriceREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataImportPricePyPSA, aes(x = iteration, y = priceImport, color = to)) +
  labs(x = "Iteration", y = "Electricity trade price ($/MWh)") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Electricity import prices over iterations") +
  facet_wrap(~ year, scales = "free")

print(pImportPriceIter)

pExportPrice <- ggplot() +
  geom_line(data = dataExportPriceREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataExportPricePyPSA, aes(x = year, y = priceExport, color = from)) +
  labs(x = "Year", y = "Electricity trade price ($/MWh)") +
  ggtitle("Electricity export prices over years") +
  facet_wrap(~ iteration, scales = "free")

print(pExportPrice)

pExportPriceIter <- ggplot() +
  geom_line(data = dataExportPriceREMIND, aes(x = iteration, y = value, color = region)) +
  geom_point(data = dataExportPricePyPSA, aes(x = iteration, y = priceExport, color = from)) +
  labs(x = "Iteration", y = "Electricity trade price ($/MWh)") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Electricity export prices over iterations") +
  facet_wrap(~ year, scales = "free")

print(pExportPriceIter)

# Plot both import and export into one
pTradePrice <- ggplot() +
  geom_line(data = dataImportPriceREMIND, aes(x = year, y = value, color = region, linetype = "Imports")) +
  geom_point(data = dataImportPricePyPSA, aes(x = year, y = priceImport, color = to, shape = "Imports")) +
  geom_line(data = dataExportPriceREMIND, aes(x = year, y = value, color = region, linetype = "Exports")) +
  geom_point(data = dataExportPricePyPSA, aes(x = year, y = priceExport, color = from, shape = "Exports")) +
  scale_shape_manual(name = NULL,
                     values = c("Imports" = 16, "Exports" = 17)) +
  scale_linetype_manual(name = NULL,
                        values = c("Imports" = "solid", "Exports" = "dashed")) +
  labs(x = "Year", y = "Electricity trade price ($/MWh)") +
  ggtitle("Electricity trade prices over years") +
  facet_wrap(~ iteration, scales = "free")

print(pTradePrice)

pTradePriceIter <- ggplot() +
  geom_line(data = dataImportPriceREMIND, aes(x = iteration, y = value, color = region, linetype = "Imports")) +
  geom_point(data = dataImportPricePyPSA, aes(x = iteration, y = priceImport, color = to, shape = "Imports")) +
  geom_line(data = dataExportPriceREMIND, aes(x = iteration, y = value, color = region, linetype = "Exports")) +
  geom_point(data = dataExportPricePyPSA, aes(x = iteration, y = priceExport, color = from, shape = "Exports")) +
  scale_shape_manual(name = NULL,
                     values = c("Imports" = 16, "Exports" = 17)) +
  scale_linetype_manual(name = NULL,
                        values = c("Imports" = "solid", "Exports" = "dashed")) +
  labs(x = "Iteration", y = "Electricity trade price ($/MWh)") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Electricity trade prices over iterations") +
  facet_wrap(~ year, scales = "free")

print(pTradePriceIter)
}
```

### Potentials

```{r potentials}
if (isTRUE(cfg$gms$c32_pypsa_potentials == "on")) {

  dataPotentialsPyPSA <- readPyPSAcsv(
      paths = file.path(pyValidationDirs, "potentials.csv")) %>%
      mutate(value = value / 1e3) %>%  # Convert MW to GW
      rename(technology = carrier) %>%
    filter(technology != "hydro") %>%
    revalue.levels(technology = rm2genTech) %>%
    group_by(year, region, technology) %>%
    summarise(value = unique(value))

  dataPotentialsREMIND <- readREMINDgdx(
      paths = rmFiles,
      gdxVar = "vm_cap",
      columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "value"),
      colFilter = list("year" = years, "region" = regions, "grade" = 1, "technology" = names(rm2genTech)),
      restoreZeros = FALSE,
      field = "up",
      recalcUnit = 1e3) %>%  # TW to GW
    revalue.levels(technology = rm2genTech) %>%
    filter(technology %in% unique(dataPotentialsPyPSA$technology),
           !is.infinite(value)) %>%
    group_by(year, region, technology) %>%
    summarise(value = unique(value))

  p <- ggplot() +
    geom_line(data = dataPotentialsREMIND, aes(x = year, y = value, color = technology)) +
    geom_point(data = dataPotentialsPyPSA, aes(x = year, y = value, color = technology)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "Potential (GW)") +
    ggtitle("Potentials over years") +
    theme(legend.position = "none") +
    facet_grid(technology ~ region, scales = "free", labeller = labeller(technology = namesTech))

  print(p)
}
```

# Convergence indicators

This section includes variables that are not exchanged directly between REMIND and PyPSA-Eur, but that should converge.

## Capacities

### Optimal capacities line charts

```{r optimal capacities line charts}
#dataCapREMIND <- readREMINDgdx(
#    paths = rmFiles,
#    gdxVar = "vm_cap",
#    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
#    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
#    restoreZeros = FALSE,
#    recalcUnit = 1e3) %>%   # TW to GW
#  select(-grade)  # Remove grade column

dataCapPyPSA <- readPyPSAcsv(
    paths = file.path(pyValidationDirs, "optimal_capacities.csv")) %>%
  filter(type == "Generator") %>%
  group_by(year,region,carrier,iteration) %>%
  revalue.levels(carrier = py2genTech) %>%
  mutate(value = value / 1e3) %>%  # Convert MW to GW
  select(!type) %>%
  rename(technology = carrier)

for (r in regList) {

  dataCapREMINDplot <- dataCapREMIND %>% 
    mutate(cap = 1E3*vm_cap) %>%
    filter(region %in% r) %>%
    revalue.levels(technology = rm2genTech) %>%
    group_by(year, technology, iteration) %>%
    summarise(cap = sum(cap)) %>%
    order.levels(technology = names(colorsTech))

  dataCapPyPSAplot <- dataCapPyPSA %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(cap = sum(value)) %>%
    order.levels(technology = names(colorsTech))

  pYear <- ggplot() +
    geom_line(data = dataCapREMINDplot, aes(x = year, y = cap, color = technology, linetype = "REMIND")) +
    geom_line(data = dataCapPyPSAplot, aes(x = year, y = cap, color = technology, linetype = "PyPSA-Eur")) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_linetype_manual(name = NULL, values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed")) +
    labs(x = "Year", y = "Capacity (GW)") +
    ggtitle("Optimal capacities over years", regSubtitle(r))
  
  print(pYear + facet_wrap(~ iteration))

  pIter <- ggplot() +
    geom_line(data = dataCapREMINDplot, aes(x = iteration, y = cap, color = technology, linetype = "REMIND")) +
    geom_line(data = dataCapPyPSAplot, aes(x = iteration, y = cap, color = technology, linetype = "PyPSA-Eur")) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_linetype_manual(name = NULL, values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed")) +
    labs(x = "Iteration", y = "Capacity (GW)") +
    scale_x_continuous(breaks = integer_breaks()) +
    ggtitle("Optimal capacities over iterations", regSubtitle(r))

  print(pIter + facet_wrap(~ year, scales = "free"))

  print(pYear + facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech)) +
          theme(legend.position = "none"))

  print(pIter + facet_grid(technology ~ year, scales = "free", labeller = labeller(technology = namesTech)) +
          theme(legend.position = "none"))
}
```

### Pre-investment capacities and investment decision

The following plots contain the pre-investment capacities and each model's capacity expansion decision.
Pre-investment capacities are determined in REMIND and passed to PyPSA-Eur as "free capacity", i.e. capacity for which PyPSA-Eur does not have to pay any CAPEX.
PyPSA-Eur should therefore only start investing into new capacity once the free pre-investment capacity has been fully used. PyPSA-Eur does not have to use all of the pre-investment capacity.

```{r pre-investment capacities and investment decision}

# Read REMIND data
dataPreInvCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_preInvCap",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_preInvCap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = 1e3)

dataPreInvCapAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_preInvCapAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_preInvCapAvg"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = 1e3) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(p32_preInvCapAvg = sum(p32_preInvCapAvg))
  
dataCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_cap",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
    restoreZeros = FALSE,
    recalcUnit = 1e3) %>%   # TW to GW
  select(-grade)  # Remove grade column

dataCapInvestREMIND <- full_join(dataPreInvCapREMIND, dataCapREMIND) %>%
  mutate(vm_cap = vm_cap,
         deltaCap = vm_cap - p32_preInvCap) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(deltaCap = sum(deltaCap),
            preInvCap = sum(p32_preInvCap)) %>%
  order.levels(technology = names(colorsTech)) %>%
  pivot_longer(cols = c("deltaCap", "preInvCap"),
               names_to = "variable",
               values_to = "value")

# Read PyPSA-Eur data
dataPreInvCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "preinstalled_capacities.csv")) %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  rename(preInvCap = value)

dataCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "optimal_capacities.csv")) %>%
  filter(type == "Generator",
         carrier != "Load shedding") %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  select(-type) %>%
  rename(cap = value)

dataCapInvestPyPSA <- full_join(dataPreInvCapPyPSA, dataCapPyPSA) %>%
  mutate(preInvCap = ifelse(is.na(preInvCap), 0, preInvCap),
         cap = ifelse(is.na(cap), 0, cap)) %>%
  mutate(deltaCap = cap - preInvCap) %>%
  rename(technology = carrier) %>%
  revalue.levels(technology = py2genTech) %>%
  order.levels(technology = names(colorsTech)) %>%
  pivot_longer(cols = c("deltaCap", "preInvCap"),
               names_to = "variable",
               values_to = "value")

for (r in regList) {
  for (i in pyIterations){
    dataCapInvestREMINDplot <- dataCapInvestREMIND %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology, variable) %>%
      summarise(value = sum(value)) %>%
      filter(!is.na(value))

    dataPreInvCapAvgREMINDplot <- dataPreInvCapAvgREMIND %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology, iteration) %>%
      summarise(p32_preInvCapAvg = sum(p32_preInvCapAvg)) %>%
      filter(!is.na(p32_preInvCapAvg))

    dataCapInvestPyPSAplot <- dataCapInvestPyPSA %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology, variable) %>%
      summarise(value = sum(value))

    # Plot if there is data
    if ((nrow(dataCapInvestREMINDplot) > 0) | (nrow(dataCapInvestPyPSAplot) > 0)) {

    pCapInvest <- ggplot() +
      geom_bar(data = dataCapInvestREMINDplot,
              mapping = aes(x = year, y = value, alpha = variable, fill = technology, linetype = "REMIND"),
              stat = "identity",
              position = position_stacknudge(x = -1),
              color = "black",
              linewidth = 0.25,
              width = 1.7) +
      geom_bar(data = dataCapInvestPyPSAplot,
              mapping = aes(x = year, y = value, alpha = variable, fill = technology, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_stacknudge(x = 1),
              color = "black",
              linewidth = 0.25,
              width = 1.7) +
      geom_point(data = dataPreInvCapAvgREMINDplot,
                mapping = aes(x = year, y = p32_preInvCapAvg, fill = technology, shape = "Averaged"),
                color = "black",
                position = position_nudge(x = -1),
                size = 1) +
      scale_shape_manual(name = NULL,
                         values = c("Averaged" = 4),
                         labels = c("Averaged" = "Avg. pre-inv. cap.")) +
      scale_alpha_manual(
        name = "Capacity",
        values = c("deltaCap" = 0.5, "preInvCap" = 1),
        labels = c("deltaCap" = "Investment",
                  "preInvCap" = "Pre-investment")) +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid",
                  "PyPSA-Eur" = "dashed")) +
      guides(linetype = guide_legend(override.aes = list(fill = NA)),
             fill = "none") +
      labs(x = "Year", y = "Capacity (GW)") +
      ggtitle(paste("Pre-investment capacities and capacity expansion over years, iteration", i), regSubtitle(r)) +
      facet_wrap(~ technology, ncol = 2, scales = "free", labeller = labeller(technology = namesTech))

    print(pCapInvest)
    }
  }
}
```

```{r capacity expansion over iterations, fig.height = 3.5}
if (FALSE) {
for (r in regList){
  for (y in years) {
    dataCapInvestREMINDplot <- dataCapInvestREMIND %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology, variable) %>%
      summarise(value = sum(value))

    dataCapInvestPyPSAplot <- dataCapInvestPyPSA %>%
      filter(region %in% r,
             year == y) %>%
      group_by(iteration, technology, variable) %>%
      summarise(value = sum(value))

    # Create plot
    pCapInvest <- ggplot() +
      geom_bar(data = dataCapInvestREMINDplot,
              mapping = aes(x = iteration, y = value, alpha = variable, fill = technology, linetype = "REMIND"),
              stat = "identity",
              position = position_stacknudge(x = -0.2),
              color = "black",
              linewidth = 0.25,
              width = 0.25) +
      geom_bar(data = dataCapInvestPyPSAplot,
              mapping = aes(x = iteration, y = value, alpha = variable, fill = technology, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_stacknudge(x = 0.2),
              color = "black",
              linewidth = 0.25,
              width = 0.25) +
      scale_alpha_manual(
        name = "Capacity",
        values = c("deltaCap" = 0.5, "preInvCap" = 1),
        labels = c("deltaCap" = "Investment",
                  "preInvCap" = "Pre-investment")) +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid",
                  "PyPSA-Eur" = "dashed")) +
      guides(linetype = guide_legend(override.aes = list(fill = NA)),
            fill = "none") +
      labs(x = "Iteration", y = "Capacity (GW)") +
      scale_x_continuous(breaks = rmIterations) +
      ggtitle(paste("Pre-investment capacities and capacity expansion over iterations, year", y), regSubtitle(r)) +
      facet_wrap(~ technology, ncol = 5, scales = "free", labeller = labeller(technology = namesTech))

    print(pCapInvest)
  }
}
}
```

### Optimal capacity bar charts side-by-side

```{r optimal capacity bar charts side-by-side}
# REMIND
#dataCapREMIND <- readREMINDgdx(
#  paths = rmFiles,
#  gdxVar = "vm_cap",
#  columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "value"),
#  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
#  restoreZeros = FALSE,
#  recalcUnit = 1e3)  # TW to GW

dataCapREMINDplot <- dataCapREMIND %>%
  revalue.levels(technology = rm2genTech) %>%
  filter(technology != "electrolysis") %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(vm_cap)) %>%
  order.levels(technology = names(colorsTech))

# Calculate minimum required capacities in REMIND from peak residual load in PyPSA-Eur
dataGenREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "v32_usableSeDispNet",
  columns = c("ttot" = "year", "all_regi" = "region", "value" = "v32_usableSeDispNet"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = FALSE,
  recalcUnit = 1E3)  # TWa to GWa

dataPeakResLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "peak_residual_loads.csv")) %>%
  mutate(absolute = absolute / 1e3)  # Convert capacities to GW

dataPeakResLoadMinREMIND <- full_join(dataPeakResLoadPyPSA %>% mutate(iteration = iteration + everyIter),
                                      dataGenREMIND) %>%
  mutate(minCap = relative * v32_usableSeDispNet)

# Read optimal capacities from the CSV files
dataCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "optimal_capacities.csv")) %>%
  rename(technology = carrier) %>%
  mutate(value = value / 1e3) %>%  # Convert capacities to GW
  filter(!is.na(value),
         technology != "Load shedding")

dataCapPyPSAplot <- dataCapPyPSA %>%
  filter(type == "Generator") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

for (r in regList){
  for (i in pyIterations){

    dataCapREMINDploti <- dataCapREMINDplot %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology) %>%
      summarise(value = sum(value))

    dataCapREMINDplotitot <- dataCapREMINDploti %>%
      group_by(year) %>%
      summarise(value = sum(value))

    dataCapPyPSAploti <- dataCapPyPSAplot %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year, technology) %>%
      summarise(value = sum(value))

    dataCapPyPSAplotitot <- dataCapPyPSAploti %>%
      group_by(year) %>%
      summarise(value = sum(value))

    dataPeakResLoadMinREMINDplot <- dataPeakResLoadMinREMIND %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year) %>%
      summarise(minCap = sum(minCap))

    dataPeakResLoadPyPSAplot <- dataPeakResLoadPyPSA %>%
      filter(region %in% r,
             iteration == i) %>%
      group_by(year) %>%
      summarise(minCap = sum(absolute))

    pCapComp <- ggplot() +
      geom_bar(data = dataCapREMINDploti,
              mapping = aes(x = year, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = -1),
              width = 1.7) +
      geom_bar(data = dataCapREMINDplotitot,
              mapping = aes(x = year, y = value, linetype = "REMIND"),
              stat = "identity",
              position = position_nudge(x = -1),
              width = 1.7,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_bar(data = dataCapPyPSAploti,
              mapping = aes(x = year, y = value, fill = technology),
              stat = "identity",
              position = position_stacknudge(x = 1),
              width = 1.7) +
      geom_bar(data = dataCapPyPSAplotitot,
              mapping = aes(x = year, y = value, linetype = "PyPSA-Eur"),
              stat = "identity",
              position = position_nudge(x = 1),
              width = 1.7,
              linewidth = 0.25,
              color = "black",
              fill = NA) +
      geom_point(data = dataPeakResLoadMinREMINDplot,
                mapping = aes(x = year, y = minCap, shape = "Peak residual load"),
                position = position_nudge(x = -1),
                fill = "white") +
      geom_point(data = dataPeakResLoadPyPSAplot,
                mapping = aes(x = year, y = minCap, shape = "Peak residual load"),
                position = position_nudge(x = 1),
                fill = "white") +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech
        ) +
      scale_linetype_manual(
        name = "Model",
        values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
      ) +
      scale_shape_manual(
        name = NULL,
        values = c("Peak residual load" = 23),
      ) +
      scale_x_continuous(breaks = years) +
      labs(x = "Year", y = "Capacity (GW)") +
      ggtitle(paste("Optimal capacity over years, iteration", i), regSubtitle(r))

    # Plot relative differences
    # Calculate relative difference between models
    dataCapDiffplot <- full_join(dataCapREMINDploti, dataCapPyPSAploti,
                      by = c("year", "technology")) %>%
      mutate(relDiff = 100 * (value.x - value.y) / sum(value.x))

    pCapDiff <- ggplot() +
      geom_bar(data = dataCapDiffplot,
               mapping = aes(x = year, y = relDiff, fill = technology),
               stat = "identity") +
      scale_x_continuous(breaks = years) +
      coord_cartesian(ylim = c(-30,30)) +
      scale_fill_manual(
        name = "Technology",
        values = colorsTech,
        labels = namesTech
      ) +
      labs(x = "Year", y = "Relative difference (%)") +
      ggtitle("Relative difference w.r.t total capacity in REMIND")
    
    leg <- get_legend(pCapComp)

    pCapPlot <- plot_grid(
      pCapComp + theme(legend.position = "none"),
      pCapDiff + theme(legend.position = "none"),
      ncol = 1,
      rel_heights = c(1, 0.5),
      labels = "auto",
      label_size = font.size)

    pCap <- plot_grid(
      pCapPlot,
      leg,
      ncol = 2,
      rel_widths = c(1, 0.2)
    )

    print(pCap)
  }
}
```

## Generation

### Generation line charts

```{r generation line charts}
dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%  # TWa to TWh
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

dataGenPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "generations.csv")) %>%
  filter(component == "Generator") %>%
  select(!component) %>%
  mutate(value = value / 1e6) %>%  # MWh to TWh
  rename(technology = carrier) %>%
  revalue.levels(technology = py2genTech)

for (r in regList) {
  dataGenREMINDplot <- dataGenREMIND %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(value = sum(value))

  dataGenPyPSAplot <- dataGenPyPSA %>%
    filter(region %in% r) %>%
    group_by(year, technology, iteration) %>%
    summarise(value = sum(value))

  pGenYear <- ggplot() +
    geom_line(data = dataGenREMINDplot, aes(x = year, y = value, color = technology, linetype = "REMIND")) +
    geom_line(data = dataGenPyPSAplot, aes(x = year, y = value, color = technology, linetype = "PyPSA-Eur")) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_linetype_manual(name = NULL, values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed")) +
    labs(x = "Year", y = "Generation (TWh)") +
    ggtitle("Generation over years", regSubtitle(r))

  print(pGenYear + facet_wrap(~ iteration))

  pGenIter <- ggplot() +
    geom_line(data = dataGenREMINDplot, aes(x = iteration, y = value, color = technology, linetype = "REMIND")) +
    geom_line(data = dataGenPyPSAplot, aes(x = iteration, y = value, color = technology, linetype = "PyPSA-Eur")) +
    scale_color_manual(name = "Technology", values = colorsTech, labels = namesTech) +
    scale_linetype_manual(name = NULL, values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed")) +
    labs(x = "Iteration", y = "Generation (TWh)") +
    scale_x_continuous(breaks = rmIterations) +
    ggtitle("Generation over iterations", regSubtitle(r))

  print(pGenIter + facet_wrap(~ year))

  print(pGenYear + facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech)) +
          theme(legend.position = "none"))

  print(pGenIter + facet_grid(technology ~ year, scales = "free", labeller = labeller(technology = namesTech)) +
          theme(legend.position = "none"))
}
```

### Generation and trade bar charts side-by-side

```{r generation bar charts side-by-side}
# REMIND generation by technology
dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%  # TWa to TWh
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

# REMIND load in total
dataLoadREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeDispNet",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE,
    recalcUnit = twa2twh)

# PyPSA-Eur generation by technology
dataGenPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "generations.csv")) %>%
  mutate(value = value / 1e6) %>%  # MWh to TWh
  rename(technology = carrier) %>%
  revalue.levels(technology = py2genTech) %>%
  order.levels(technology = names(colorsTech))

# PyPSA-Eur load in total
dataLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_loads.csv")) %>%
  mutate(value = value / 1e6)  # Convert MWh to TWh

if (isTRUE(cfg$gms$c32_pypsa_trade == "off")) {
  for (r in regList) {
    for (i in rmIterations){

      dataGenREMINDploti <- dataGenREMIND %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year, technology) %>%
        summarise(value = sum(value))

      dataGenREMINDplotitot <- dataGenREMINDploti %>%
        group_by(year) %>%
        summarise(value = sum(value))

      dataLoadREMINDploti <- dataLoadREMIND %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year) %>%
        summarise(value = sum(value))

      dataGenPyPSAploti <- dataGenPyPSA %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year, technology) %>%
        summarise(value = sum(value))

      dataGenPyPSAplotitot <- dataGenPyPSAploti %>%
        group_by(year) %>%
        summarise(value = sum(value))

      dataLoadPyPSAploti <- dataLoadPyPSA %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year) %>%
        summarise(value = sum(value))

      pGenComp <- ggplot() +
        geom_bar(data = dataGenREMINDploti,
                mapping = aes(x = year, y = value, fill = technology),
                stat = "identity",
                position = position_stacknudge(x = -1),
                width = 1.7) +
        geom_bar(data = dataGenREMINDplotitot,
                mapping = aes(x = year, y = value, linetype = "REMIND"),
                stat = "identity",
                position = position_nudge(x = -1),
                width = 1.7,
                linewidth = 0.25,
                color = "black",
                fill = NA) +
        geom_point(data = dataLoadREMINDploti,
                  mapping = aes(x = year, y = value, color = "Load"),
                  position = position_nudge(x = -1),
                  shape = 4) +
        geom_bar(data = dataGenPyPSAploti,
                mapping = aes(x = year, y = value, fill = technology),
                stat = "identity",
                position = position_stacknudge(x = 1),
                width = 1.7) +
        geom_bar(data = dataGenPyPSAplotitot,
                mapping = aes(x = year, y = value, linetype = "PyPSA-Eur"),
                stat = "identity",
                position = position_nudge(x = 1),
                width = 1.7,
                linewidth = 0.25,
                color = "black",
                fill = NA) +
        geom_point(data = dataLoadPyPSAploti,
                  mapping = aes(x = year, y = value, color = "Load"),
                  position = position_nudge(x = 1),
                  shape = 4) +
        scale_fill_manual(
          name = "Technology",
          values = colorsTech,
          labels = namesTech) +
        scale_linetype_manual(
          name = "Model",
          values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
        ) +
        scale_color_manual(
          name = NULL,
          values = c("Load" = "black"),
        ) +
        scale_x_continuous(breaks = years) +
        labs(x = "Year", y = "Generation (TWh)") +
        ggtitle(paste("Generation over years, iteration", i), regSubtitle(r))

      # Plot relative differences
      dataGenDiffplot <- full_join(dataGenREMINDploti, dataGenPyPSAploti,
                        by = c("year", "technology")) %>%
        mutate(relDiff = 100 * (value.x - value.y) / sum(value.x))

      pGenDiff <- ggplot() + 
        geom_bar(data = dataGenDiffplot,
                mapping = aes(x = year, y = relDiff, fill = technology),
                stat = "identity") +
        scale_x_continuous(breaks = years) +
        coord_cartesian(ylim = c(-30,30)) +
        scale_fill_manual(
          name = "Technology",
          values = colorsTech,
          labels = namesTech
        ) +
        labs(x = "Year", y = "Relative difference (%)") +
        ggtitle("Relative difference w.r.t total generation in REMIND")

      leg <- get_legend(pGenComp)

      pGenPlot <- plot_grid(
        pGenComp + theme(legend.position = "none"),
        pGenDiff + theme(legend.position = "none"),
        ncol = 1,
        rel_heights = c(1, 0.5),
        labels = "auto",
        label_size = font.size)

      pGen <- plot_grid(
        pGenPlot,
        leg,
        ncol = 2,
        rel_widths = c(1, 0.2)
      )

      print(pGen)
    }
  }
}

if (isTRUE(cfg$gms$c32_pypsa_trade == "on")) {
  for (r in regList) {
    for (i in rmIterations){

      dataGenREMINDploti <- dataGenREMIND %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year, technology) %>%
        summarise(value = sum(value))

      dataImportREMINDploti <- dataImportREMIND %>%
        filter(region %in% r,
              iteration == i) %>%
        mutate(technology = "Import") %>%
        group_by(year, technology) %>%
        summarise(value = sum(vm_Mport))

      dataExportREMINDploti <- dataExportREMIND %>%
        filter(region %in% r,
              iteration == i) %>%
        mutate(technology = "Export") %>%
        group_by(year, technology) %>%
        summarise(value = - sum(vm_Xport))

      dataGenTradeREMINDploti <- bind_rows(dataGenREMINDploti, dataImportREMINDploti, dataExportREMINDploti) %>%
        order.levels(technology = c("Import", names(colorsTech), "Export"))

      dataGenTradeREMINDplotitot <- dataGenTradeREMINDploti %>%
        group_by(year, technology == "Import", technology == "Export") %>%
        summarise(value = sum(value))

      dataLoadREMINDploti <- dataLoadREMIND %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year) %>%
        summarise(value = sum(value))

      dataGenPyPSAploti <- dataGenPyPSA %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year, technology) %>%
        summarise(value = sum(value))

      dataImportPyPSAploti <- dataImportPyPSA %>%
        mutate(iteration = iteration - 1) %>%
        filter(region %in% r,
              iteration == i) %>%
        mutate(technology = "Import") %>%
        group_by(year, technology) %>%
        summarise(value = sum(value))

      dataExportPyPSAploti <- dataExportPyPSA %>%
        mutate(iteration = iteration - 1) %>%
        filter(region %in% r,
              iteration == i) %>%
        mutate(technology = "Export") %>%
        group_by(year, technology) %>%
        summarise(value = - sum(value))

      dataGenTradePyPSAploti <- bind_rows(dataGenPyPSAploti, dataImportPyPSAploti, dataExportPyPSAploti) %>%
        order.levels(technology = c("Import", names(colorsTech), "Export"))

      dataGenTradePyPSAplotitot <- dataGenTradePyPSAploti %>%
        group_by(year, technology == "Import", technology == "Export") %>%
        summarise(value = sum(value))

      dataLoadPyPSAploti <- dataLoadPyPSA %>%
        filter(region %in% r,
              iteration == i) %>%
        group_by(year) %>%
        summarise(value = sum(value))

      pGenComp <- ggplot() +
        geom_col(data = dataGenTradeREMINDploti,
                mapping = aes(x = year, y = value, fill = technology),
                position = position_stacknudge(x = -1),
                width = 1.7) +
        geom_col(data = dataGenTradeREMINDplotitot,
                mapping = aes(x = year, y = value, linetype = "REMIND"),
                position = position_stacknudge(x = -1),
                width = 1.7,
                linewidth = 0.25,
                color = "black",
                fill = NA) +
        geom_point(data = dataLoadREMINDploti,
                  mapping = aes(x = year, y = value, color = "Load"),
                  position = position_nudge(x = -1),
                  shape = 4) +
        geom_col(data = dataGenTradePyPSAploti,
                mapping = aes(x = year, y = value, fill = technology),
                position = position_stacknudge(x = 1),
                width = 1.7) +
        geom_col(data = dataGenTradePyPSAplotitot,
                mapping = aes(x = year, y = value, linetype = "PyPSA-Eur"),
                position = position_stacknudge(x = 1),
                width = 1.7,
                linewidth = 0.25,
                color = "black",
                fill = NA) +
        geom_point(data = dataLoadPyPSAploti,
                  mapping = aes(x = year, y = value, color = "Load"),
                  position = position_nudge(x = 1),
                  shape = 4) +
        scale_fill_manual(
          name = "Domestic generation",
          values = c("Import" = "#99E8A5", colorsTech, "Export" = "#EBBAA7"),
          breaks = names(colorsTech),
          labels = namesTech,
          guide = guide_legend(order = 4)) +
        scale_linetype_manual(
          name = "Model",
          values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
          guide = guide_legend(order = 2)
        ) +
        scale_color_manual(
          name = NULL,
          values = c("Load" = "black"),
          guide = guide_legend(order = 1)
        ) +
        # Add fake data for legend
        new_scale_fill() +
        geom_col(data = dataGenTradeREMINDploti %>%
                    filter(year == 2025, technology %in% c("Import", "Export")) %>%
                    mutate(value = 0),
                mapping = aes(x = year, y = value, fill = technology)) +
        scale_fill_manual(
          name = "Trade",
          values = c("Import" = "#99E8A5", "Export" = "#EBBAA7"),
          guide = guide_legend(order = 3)
        ) +
        scale_x_continuous(breaks = years) +
        labs(x = "Year", y = "Generation (TWh)") +
        ggtitle(paste("Generation and trade, iteration", i), regSubtitle(r))

      # Plot relative differences
      dataGenTradeDiffplot <- full_join(dataGenTradeREMINDploti, dataGenTradePyPSAploti,
                        by = c("year", "technology")) %>%
        mutate(relDiff = 100 * (value.x - value.y) / sum(value.x))

      pGenDiff <- ggplot() + 
        geom_bar(data = dataGenTradeDiffplot,
                mapping = aes(x = year, y = relDiff, fill = technology),
                stat = "identity") +
        scale_x_continuous(breaks = years) +
        coord_cartesian(ylim = c(-30,30)) +
        scale_fill_manual(
          name = "Technology",
          values = c("Import" = "#99E8A5", colorsTech, "Export" = "#EBBAA7"),
          labels = namesTech
        ) +
        labs(x = "Year", y = "Relative difference (%)") +
        ggtitle("Relative difference w.r.t total load in REMIND")

      leg <- get_legend(pGenComp)

      pGenPlot <- plot_grid(
        pGenComp + theme(legend.position = "none"),
        pGenDiff + theme(legend.position = "none"),
        ncol = 1,
        rel_heights = c(1, 0.5),
        labels = "auto",
        label_size = font.size)

      pGen <- plot_grid(
        pGenPlot,
        leg,
        ncol = 2,
        rel_widths = c(1, 0.2)
      )

      print(pGen)
    }
  }
}
```

## Pre-factor/anticipation parametrisation

### Generation shares of REMIND technologies

Generation shares are not explicitly coupled between REMIND and PyPSA-Eur, but used to parametrise the pre-factor equations to avoid oscillations. If they don't converge, there is a always a distortion in the variables passed from PyPSA-Eur to REMIND.

```{r generation shares}

dataGenShareREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_shSeElDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE)

dataGenSharePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "generation_shares.csv")) %>%
  mutate(technology = as.factor(carrier))

unique_technologies <- unique(dataGenShareREMIND$technology)

techset1 <- unique_technologies[1:ceiling(length(unique_technologies) / 2)]
techset2 <- unique_technologies[(ceiling(length(unique_technologies) / 2) + 1):length(unique_technologies)]

techsets <- list(techset1, techset2)

for (r in regions) {
  for (t in techsets) {
    dataGenShareREMINDplot <- dataGenShareREMIND %>%
      filter(region == r,
             technology %in% t)

    dataGenSharePyPSAplot <- dataGenSharePyPSA %>%
      filter(region == r,
             technology %in% t)

    pGenShareYear <- ggplot() +
      geom_line(data = dataGenShareREMINDplot, aes(x = year, y = value, color = "REMIND")) +
      geom_line(data = dataGenSharePyPSAplot, aes(x = year, y = value, color = "PyPSA-Eur")) +
      scale_color_discrete(name = "Model") +
      labs(x = "Year", y = "Generation share") +
      ggtitle("Generation shares over years", regSubtitle(r)) +
      facet_grid(technology ~ iteration, scales = "free")

    print(pGenShareYear)

    pGenShareIter <- ggplot() +
      geom_line(data = dataGenShareREMINDplot, aes(x = iteration, y = value, color = "REMIND")) +
      geom_line(data = dataGenSharePyPSAplot, aes(x = iteration, y = value, color = "PyPSA-Eur")) +
      scale_color_discrete(name = "Model") +
      labs(x = "Iteration", y = "Generation share") +
      scale_x_continuous(breaks = integer_breaks()) +
      ggtitle("Generation shares over iterations", regSubtitle(r)) +
      facet_grid(technology ~ year, scales = "free")

    print(pGenShareIter)
  }
}
```

### Generation shares of REMIND regions

The following plots show the generation shares of REMIND regions. They are not explicitly coupled between REMIND and PyPSA-Eur, but used to parametrise the pre-factor equations for electricity trade. If they don't converge, there is a always a distortion in the electricity trade volume passed from PyPSA-Eur to REMIND.

```{r generation region shares}

dataGenRegionShareREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "v32_shSeElRegi",
  columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = FALSE)

dataGenRegionSharePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "generation_region_shares.csv"))

p <- ggplot() +
  geom_line(data = dataGenRegionShareREMIND, aes(x = year, y = value, color = "REMIND")) +
  geom_line(data = dataGenRegionSharePyPSA, aes(x = year, y = value, color = "PyPSA-Eur")) +
  scale_color_discrete(name = "Model") +
  labs(x = "Year", y = "Generation share") +
  ggtitle("Generation region shares over years") +
  facet_grid(region ~ iteration, scales = "free")

print(p)

pIter <- ggplot() +
  geom_line(data = dataGenRegionShareREMIND, aes(x = iteration, y = value, color = "REMIND")) +
  geom_line(data = dataGenRegionSharePyPSA, aes(x = iteration, y = value, color = "PyPSA-Eur")) +
  scale_color_discrete(name = "Model") +
  labs(x = "Iteration", y = "Generation share") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("Generation region shares over iterations") +
  facet_grid(region ~ year, scales = "free")

print(pIter)

# Show whether REMIND generation region shares sum up to 1 using a stacked bar chart

pREMIND <- ggplot() +
  geom_bar(data = dataGenRegionShareREMIND, aes(x = year, y = value, fill = region),
           stat = "identity") +
  scale_fill_discrete(name = "Region") +
  labs(x = "Year", y = "Generation share") +
  ggtitle("REMIND generation region shares over years", "Useful to inspect whether shares add up to 1 as they should") +
  facet_wrap(~ iteration)

print(pREMIND)

pREMINDiter <- ggplot() +
  geom_bar(data = dataGenRegionShareREMIND, aes(x = iteration, y = value, fill = region),
           stat = "identity") +
  scale_fill_discrete(name = "Region") +
  labs(x = "Iteration", y = "Generation share") +
  scale_x_continuous(breaks = integer_breaks()) +
  ggtitle("REMIND generation region shares over iterations", "Useful to inspect whether shares add up to 1 as they should") +
  facet_wrap(~ year)

print(pREMINDiter)

```

## Electricity prices

### Electricity price only

```{r electricity price}
# REMIND
dataElecPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_SEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "value" = "pm_SEPrice"),
    colFilter = list("year" = years, "region" = regions, "secarrier" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh) %>%  # T$/TWa to $/MWh
  select(-secarrier)

# PyPSA-Eur
dataElecPricePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "load_prices.csv")) %>%
  filter(carrier == "AC") %>%
  select(!carrier)

pElecPriceYear <- ggplot() +
  geom_line(data = dataElecPriceREMIND,
            mapping = aes(x = year, y = pm_SEPrice, color = "REMIND")) +
  geom_line(data = dataElecPricePyPSA,
            mapping = aes(x = year, y = value, color = "PyPSA-Eur")) +
  scale_color_discrete(name = "Model") +
  labs(x = "Year", y = "Electricity price ($/MWh)") +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("Electricity price over years")

if (length(regions) > 1) {
  pElecPriceYear <- pElecPriceYear + facet_grid(region ~ iteration, scales = "free")
} else {
  pElecPriceYear <- pElecPriceYear + facet_wrap(~ iteration, scales = "free")
}

print(pElecPriceYear)

pElecPriceIter <- ggplot() +
  geom_line(data = dataElecPriceREMIND,
            mapping = aes(x = iteration, y = pm_SEPrice, color = "REMIND")) +
  geom_line(data = dataElecPricePyPSA,
            mapping = aes(x = iteration, y = value, color = "PyPSA-Eur")) +
  scale_color_discrete(name = "Model") +
  labs(x = "Iteration", y = "Electricity price ($/MWh)") +
  scale_x_continuous(breaks = rmIterations) +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("Electricity price over iterations")

if (length(regions) > 1) {
  pElecPriceIter <- pElecPriceIter + facet_grid(region ~ year, scales = "free")
} else {
  pElecPriceIter <- pElecPriceIter + facet_wrap(~ year, scales = "free")
}

print(pElecPriceIter)
```

### Electricity and trade prices

```{r electricity and trade prices}

if (isTRUE(cfg$gms$c32_pypsa_trade == "on")) {

  dataImportPricePyPSA <- dataImportPricePyPSA %>%
    rename(region = to)

  dataExportPricePyPSA <- dataExportPricePyPSA %>%
    rename(region = from)

  for (r in regions) {

    pPricesYear <- ggplot() +
      geom_line(data = dataElecPriceREMIND %>% filter(region == r),
                mapping = aes(x = year, y = pm_SEPrice, color = "REMIND")) +
      geom_line(data = dataElecPricePyPSA %>% filter(region == r),
                mapping = aes(x = year, y = value, color = "PyPSA-Eur")) +
      geom_line(data = dataImportPricePyPSA %>% filter(region == r),
                mapping = aes(x = year, y = priceImport, color = "Import price (PyPSA-Eur)")) +
      geom_line(data = dataExportPricePyPSA %>% filter(region == r),
                mapping = aes(x = year, y = priceExport, color = "Export price (PyPSA-Eur)")) +
      scale_color_discrete(name = NULL,
                          breaks = c("PyPSA-Eur", "REMIND", "Import price (PyPSA-Eur)", "Export price (PyPSA-Eur)")) +
      labs(x = "Year", y = "Electricity price ($/MWh)") +
      scale_y_continuous(limits = c(0, NA)) +
      ggtitle("Electricity price over years", regSubtitle(r)) +
      facet_wrap(~ iteration, scales = "free")

    print(pPricesYear)

    pPricesIter <- ggplot() +
      geom_line(data = dataElecPriceREMIND %>% filter(region == r),
                mapping = aes(x = iteration, y = pm_SEPrice, color = "REMIND")) +
      geom_line(data = dataElecPricePyPSA %>% filter(region == r),
                mapping = aes(x = iteration, y = value, color = "PyPSA-Eur")) +
      geom_line(data = dataImportPricePyPSA %>% filter(region == r),
                mapping = aes(x = iteration, y = priceImport, color = "Import price (PyPSA-Eur)")) +
      geom_line(data = dataExportPricePyPSA %>% filter(region == r),
                mapping = aes(x = iteration, y = priceExport, color = "Export price (PyPSA-Eur)")) +
      scale_color_discrete(name = NULL,
                          breaks = c("PyPSA-Eur", "REMIND", "Import price (PyPSA-Eur)", "Export price (PyPSA-Eur)")) +
      labs(x = "Iteration", y = "Electricity price ($/MWh)") +
      scale_x_continuous(breaks = rmIterations) +
      scale_y_continuous(limits = c(0, NA)) +
      ggtitle("Electricity price over iterations") +
      facet_wrap(~ year, scales = "free")
    
    print(pPricesIter)
  }
}

```

## LCOEs

In the long-term equilibrium the levelised cost of electricity (LCOE) should be the same as the market value for each technology.

```{r lcoe remind2}
if (FALSE){
devtools::load_all("/p/tmp/adrianod/remind2_branches/remind2_LCOEReport")

lcoe.remind2 <- remind2::reportLCOE(rmFiles[7], output.type = "marginal")

test <- lcoe.remind2 %>%
  as_tibble() %>%
  filter(region == "DEU",
         output == "seel",
         cost != "Total LCOE",
         period >= 2025) %>%
  order.levels(cost = c("CO2 Tax Cost", "Fuel Cost", "OMV Cost", "OMF Cost", "Investment Cost", "Second Fuel Cost"))

p <- ggplot() + 
  geom_bar(data = test,
           mapping = aes(x = period, y = value, fill = cost),
           stat = "identity",
           position = "stack") +
  facet_wrap(~ tech, scales = "free")

}
```

### Simple LCOE

This section contains a simple calculation of the LCOE for each technology. It does not account for changes in the capacity factor, depreciation of capital stock and time-dependent components (i.e. fuel costs, CO2 prices).

This means, for example, that we can use the annuity factor for investment costs.

```{r LCOE simple}
if (FALSE) {
# REMIND: 1) Investment costs in USD/MWh
# Investment cost = Overnight cost (CAPEX) * annuity factor / (capfac * 8760h)

# Read overnight costs
vm_costTeCapital <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_costTeCapital",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_costTeCapital"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    recalcUnit = trUSDpTW2USDpMW)

# Read annuity factor
#p_teAnnuity <- readGDX(rmFiles[1], "p_teAnnuity") %>%
#  as_tibble() %>%
#  rename(technology = all_te, p_teAnnuity = value) %>%
#  select(!region)

# Calculate annuity factor using p_r
# Annuity factor = 1 / ( sum(opTimeYr, pm_omeg) / (1 + p_r)^optimeYr
# sum(opTimeYr, (sum(regi, pm_omeg(regi,opTimeYr,te))/sum(regi,1)) / 1.06**opTimeYr.val )
pm_omeg <- readGDX(rmFiles[1], "pm_omeg") %>%
  as_tibble() %>%
  rename(region = all_regi, technology = all_te, pm_omeg = value)

p_r <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p_r",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "p_r"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE)

annuityfactor <- right_join(pm_omeg, p_r, by = c("region"), relationship = "many-to-many") %>%
  group_by(region, year, technology, iteration) %>%
  summarise(annuityfactor = 1 / sum(pm_omeg / (1 + p_r)^opTimeYr))

# Calculate capacity factors for VRE technologies
vm_capFac <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_capFac",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_capFac"),
    colFilter = list(year = years, "region" = regions, "technology" = names(rm2genTech)))
    
teReNoBio <- readGDX(rmFiles[1], "teReNoBio")

vm_capDistr <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_capDistr",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "rlf", "value" = "vm_capDistr"),
    colFilter = list(year = years, "region" = regions, "technology" = teReNoBio),
    restoreZeros = FALSE)

pm_dataren <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataren",
    columns = c("all_regi" = "region", "all_te" = "technology", "char" = "char", "rlf" = "rlf", "value" = "pm_dataren_nur"),
    colFilter = list("region" = regions, "char" = "nur", "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-char) %>%
  replace_na(list(pm_dataren_nur = 0))

capfacVRE <- vm_capDistr %>%
  left_join(pm_dataren, relationship = "many-to-many") %>%
  left_join(vm_capFac) %>%
  replace_na(list(pm_dataren_nur = 0)) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(capfac = sum(vm_capFac * vm_capDistr * pm_dataren_nur) / sum(vm_capDistr)) %>%
  select(year, region, technology, capfac, iteration)

# Calculate capacity factors for dispatchable technologies
capfacDisp <- vm_capFac %>%
  filter(!(technology %in% teReNoBio)) %>%
  rename(capfac = vm_capFac)

capfac <- bind_rows(capfacVRE, capfacDisp)

# Calculate LCOE
lcoe.investment <- vm_costTeCapital %>%
  left_join(annuityfactor) %>%
  left_join(capfac) %>%
  mutate(lcoe = vm_costTeCapital * annuityfactor / (capfac * 8760)) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "investment")

# REMIND: FOM
pm_data_omf <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "char", "all_te" = "technology", "value" = "pm_data_omf"),
    colFilter = list("region" = regions, "char" = "omf", "technology" = names(rm2genTech)),
    restoreZeros = FALSE)

lcoe.fom <- vm_costTeCapital %>%
  left_join(pm_data_omf) %>%
  left_join(capfac) %>%
  mutate(lcoe = vm_costTeCapital * pm_data_omf / (capfac * 8760)) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "fom")

# REMIND: VOM
pm_data <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_data",
    columns = c("all_regi" = "region", "char" = "char", "all_te" = "technology", "value" = "pm_data_omv"),
    colFilter = list("region" = regions, "char" = "omv", "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh)

lcoe.vom <- pm_data %>%
  tidyr::crossing(year = years) %>%
  rename(lcoe = pm_data_omv) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "vom")

# REMIND: Fuel costs
pm_eta_conv <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_eta_conv",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2pyTech)),
    restoreZeros = FALSE) %>%
  filter(eta > 0)

pm_dataeta <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataeta",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "eta"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2pyTech)),
    restoreZeros = FALSE) %>%
  filter(eta > 0)

eta <- bind_rows(pm_eta_conv, pm_dataeta)

pe2seTech <- gdx::readGDX(rmFiles[1], "pe2se") %>%
  rename(pecarrier = all_enty,
         secarrier = all_enty1,
         technology = all_te) %>%
  filter(secarrier == "seel", technology %in% names(rm2pyTech)) %>%
  select(pecarrier, technology)

pm_PEPrice <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_PEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "pecarrier", "value" = "pm_PEPrice"),
    colFilter = list("year" = years, "region" = regions),
    recalcUnit = trUSDpTWa2USDpMWh)

lcoe.fuel <- pm_PEPrice %>%
  right_join(pe2seTech, by = c("pecarrier"), relationship = "many-to-many") %>%
  full_join(eta) %>%
  mutate(lcoe = pm_PEPrice / eta) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "fuel")

# REMIND: CO2 costs
p_priceCO2 <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "p_priceCO2",
  columns = c("tall" = "year", "all_regi" = "region", "value" = "p_priceCO2"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = TRUE,
  recalcUnit = 1 / tC2tCO2)

fm_dataemiglob_co2int <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "fm_dataemiglob",
    columns = c("all_enty" = "pecarrier", "all_enty1" = "secarrier", "all_te" = "technology", "all_enty2" = "gas", "value" = "co2int"),
    colFilter = list("secarrier" = "seel", "gas" = "co2", technology = names(rm2pyTech)),
    restoreZeros = FALSE,
    recalcUnit = 1E9 * tC2tCO2 / twa2mwh) %>%
  group_by(technology) %>%
  summarise(co2int = unique(co2int))

lcoe.co2 <- full_join(p_priceCO2, eta) %>%
  full_join(fm_dataemiglob_co2int) %>%
  replace_na(list(co2int = 0)) %>%
  mutate(lcoe = p_priceCO2 * co2int / eta) %>%
  select(year, region, technology, lcoe, iteration) %>%
  mutate(type = "co2")

# Weights
dataGenTechREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-secarrier)

# Toal LCOEs
lcoeREMIND <- bind_rows(lcoe.investment, lcoe.fom, lcoe.vom, lcoe.fuel, lcoe.co2) %>%
  order.levels(type = c("co2", "fuel", "vom", "fom", "investment")) %>%
  full_join(dataGenTechREMIND) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, type, iteration) %>%
  summarise(lcoe = sum(lcoe * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp))

# Market value = electricity price and markups
dataElecPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_SEPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "secarrier" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh) %>%  # T$/TWa to $/MWh
  tidyr::crossing(technology = names(rm2genTech)) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "elec")

dataMarkupREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_PyPSAMarkup",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vm_PyPSAMarkup"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh)

dataElecPlusMarkupREMIND <- dataElecPriceREMIND %>%
  left_join(dataMarkupREMIND) %>%
  mutate(value = value + vm_PyPSAMarkup) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "elec + markup")

# Peak capacity shadow price
dataPeakCapShadowPriceREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PeakResLoadShadowPrice",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PeakResLoadShadowPrice"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = TRUE,
    recalcUnit = trUSDpTWa2USDpMWh
  )

dataElecPlusMarkupPlusPeakShadowREMIND <- dataElecPlusMarkupREMIND %>%
  left_join(dataPeakCapShadowPriceREMIND) %>%
  mutate(value = value + p32_PeakResLoadShadowPrice) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "elec + markup + peakcap")

dataPricesREMIND <- bind_rows(dataElecPriceREMIND, dataElecPlusMarkupREMIND, dataElecPlusMarkupPlusPeakShadowREMIND) %>%
  order.levels(type = c("elec + markup + peakcap", "elec + markup", "elec")) %>%
  full_join(dataGenTechREMIND) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration, type) %>%
  summarise(value = sum(value * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp))

colorsInvest <- c(
  "co2" = "#e41a1c",
  "fuel" = "#377eb8",
  "vom" = "#4daf4a",
  "fom" = "#984ea3",
  "investment" = "#ff7f00")

labelsInvest <- c(
  "co2" = "CO2 cost",
  "fuel" = "Fuel cost",
  "vom" = "Variable O&M cost",
  "fom" = "Fixed O&M cost",
  "investment" = "Investment cost")

for (i in pyIterations) {
  p <- ggplot() +
    geom_bar(data = lcoeREMIND %>% filter(iteration == i),
            aes(x = year, y = lcoe, fill = type),
            stat = "identity",
            position = "stack",
            alpha = 0.8) +
    geom_line(data = dataPricesREMIND %>% filter(iteration == i),
              aes(x = year, y = value, linetype = type),
              linewidth = 0.5) +
    scale_linetype_manual(
      name = NULL,
      values = c("elec + markup + peakcap" = "solid",
                "elec + markup" = "dashed",
                "elec" = "dotted"),
      labels = c("elec + markup + peakcap" = "Elec. price + Markup +\nPeak capacity shadow price",
                "elec + markup" = "Elec. price + Markup",
                "elec" = "Elec. price"),
      guide = guide_legend(order = 1)
    ) +
    scale_fill_manual(
      name = "Cost component",
      values = colorsInvest,
      labels = labelsInvest,
      guide = guide_legend(order = 2)
    ) +
    labs(x = "Year", y = "LCOE ($/MWh)") +
    facet_wrap(~ technology, scales = "free", labeller = labeller(technology = namesTech)) +
    ggtitle(paste("LCOEs (simple) vs. market values in REMIND, iteration", i))

  print(p)
}
}
```

```{r lcoe pypsa}
if (FALSE) {

dataCostsPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(str_detect(further.description, "^Extracted from REMIND-EU")) %>%
  select(-further.description, -original_value, -source)

# PyPSA-Eur: Capital costs
dataCapfac <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "capacity_factors.csv")) %>%
  revalue.levels(carrier = rm2pyTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(capfac = unique(value)) %>%
  rename(technology = carrier)

lcoe.investment <- dataCostsPyPSA %>%
  filter(parameter %in% c("investment", "lifetime", "discount_rate"),
         !(technology %in% c("solar-utility", "solar-rooftop"))) %>%
  select(-unit) %>%
  pivot_wider(names_from = parameter, values_from = value) %>%
  mutate(annuity = 0.05 / (1 - (1 + 0.05)**(-lifetime))) %>%
  full_join(dataCapfac) %>%
  mutate(lcoe = annuity * investment / (capfac * 8760)) %>%
  select(year, technology, lcoe, iteration) %>%
  mutate(type = "investment")

# PyPSA-Eur: FOM
lcoe.fom <- dataCostsPyPSA %>%
  filter(parameter %in% c("investment", "FOM"),
         !(technology %in% c("solar-utility", "solar-rooftop"))) %>%
  select(-unit) %>%
  pivot_wider(names_from = parameter, values_from = value) %>%
  full_join(dataCapfac) %>%
  mutate(lcoe = 1e-2 * investment * FOM / (capfac * 8760)) %>%  # FOM is in percent
  select(year, technology, lcoe, iteration) %>%
  mutate(type = "fom")

# PyPSA-Eur: VOM
lcoe.vom <- dataCostsPyPSA %>%
  filter(parameter %in% c("VOM")) %>%
  mutate(lcoe = value) %>%
  select(year, technology, lcoe, iteration) %>%
  mutate(type = "vom")

# PyPSA-Eur: Fuel costs
lcoe.fuel <- dataCostsPyPSA %>%
  filter(parameter %in% c("fuel", "efficiency"),
         !(technology %in% c("solar-utility", "solar-rooftop"))) %>%
  select(-unit) %>%
  pivot_wider(names_from = parameter, values_from = value) %>%
  mutate(lcoe = fuel / efficiency) %>%
  select(year, technology, lcoe, iteration) %>%
  mutate(type = "fuel")

# PyPSA-Eur: CO2 costs
dataCO2PricePyPSA <- readPyPSAcsv(
    paths = file.path(pyResultsDirs, "co2_price_scenarios.csv")) %>% 
  # Extract the CO2 price from the opts columns which starts with Ep followed by a number of format 0.0
  mutate(co2 = as.numeric(str_extract(opts, "(?<=Ep)\\d+\\.\\d{1,2}"))) %>%
  select(year, iteration, co2)

lcoe.co2 <- dataCostsPyPSA %>%
  filter(parameter %in% c("CO2 intensity", "efficiency"),
         !(technology %in% c("solar-utility", "solar-rooftop"))) %>%
  select(-unit) %>%
  pivot_wider(names_from = parameter, values_from = value) %>%
  full_join(dataCO2PricePyPSA) %>%
  mutate(lcoe = co2 * `CO2 intensity` / efficiency) %>%
  select(year, technology, lcoe, iteration) %>%
  mutate(type = "co2")

# PyPSA-Eur total LCOE
lcoePyPSA <- bind_rows(lcoe.investment, lcoe.fom, lcoe.vom, lcoe.fuel, lcoe.co2) %>%
  order.levels(type = c("co2", "fuel", "vom", "fom", "investment")) %>%
  revalue.levels(technology = py2genTech)

# Market values
dataMarketValuePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "market_values.csv")) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  rename(technology = carrier) %>%
  quitte::order.levels(technology = names(namesTech)) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "market value")

# Electricity prices
dataElecPricePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "load_prices.csv")) %>%
  filter(carrier == "AC") %>%
  select(!carrier) %>%
  tidyr::crossing(technology = unique(rm2genTech)) %>%
  select(year, region, technology, value, iteration) %>%
  mutate(type = "elec")

dataPricesPyPSA <- bind_rows(dataMarketValuePyPSA, dataElecPricePyPSA) %>%
  order.levels(type = c("market value", "elec"))

# Plots
for (i in rmIterations) {
  p <- ggplot() +
    geom_bar(data = lcoePyPSA %>% filter(iteration == i),
            aes(x = year, y = lcoe, fill = type),
            stat = "identity",
            position = "stack",
            alpha = 0.8) +
    geom_line(data = dataPricesPyPSA %>% filter(iteration == i),
              aes(x = year, y = value, linetype = type),
              linewidth = 0.5) +
    scale_linetype_manual(
      name = NULL,
      values = c("market value" = "solid",
                "elec" = "dotted"),
      labels = c("market value" = "Market value",
                "elec" = "Electricity price"),
      guide = guide_legend(order = 1)
    ) +
    scale_fill_manual(
      name = "Cost component",
      values = colorsInvest,
      labels = labelsInvest,
      guide = guide_legend(order = 2)
    ) +
    labs(x = "Year", y = "LCOE ($/MWh)") +
    facet_wrap(~ technology, scales = "free", labeller = labeller(technology = namesTech)) +
    ggtitle(paste("LCOEs vs. market values in PyPSA, iteration", i))

  print(p)
}
}
```

# Model-specific variables

## REMIND

### Electricity balance equation

This section shows all terms of REMIND's secondary energy electricity (`seel`) equation in `q32_balSe`.

```{r electricity balance equation}

pe2se <- gdx::readGDX(rmFiles[1], "pe2se") %>%
  filter(all_enty1 == "seel")

se2se <- gdx::readGDX(rmFiles[1], "se2se") %>%
  filter(all_enty1 == "seel")

pc2te <- gdx::readGDX(rmFiles[1], "pc2te") %>%
  filter(all_enty2 == "seel")

dataProdSe <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_prodSe",
    columns = c("tall" = "year", "all_regi" = "region", "all_enty" = "tech_pe", "all_enty1" = "secarrier", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "secarrier" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  select(-tech_pe, -secarrier)

# LHS: Term 1


# LHS: Term 2


```


### Sectoral electricity demand

Electricity load passed to PyPSA vs sectoral electricity demand (including T&D losses).

## PyPSA-Eur

### Market values

```{r market values}
dataMarketValuePyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "market_values.csv")) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  quitte::order.levels(carrier = names(namesTech))

pMarketValueYear <- ggplot() +
  geom_line(data = dataMarketValuePyPSA, aes(x = year, y = value, color = carrier)) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Year", y = "Market value ($/MWh)") +
  ggtitle("Market values by year")

if (length(regions) > 1) {
  pMarketValueYear <- pMarketValueYear + facet_grid(region ~ iteration, scales = "free")
} else {
  pMarketValueYear <- pMarketValueYear + facet_wrap(~ iteration)
}

print(pMarketValueYear)

pMarketValueIter <- ggplot() +
  geom_line(data = dataMarketValuePyPSA, aes(x = iteration, y = value, color = carrier)) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
  ) +
  labs(x = "Iteration", y = "Market value ($/MWh)") +
  ggtitle("Market values by iteration")

if (length(regions) > 1) {
  pMarketValueIter <- pMarketValueIter + facet_grid(region ~ year, scales = "free")
} else {
  pMarketValueIter <- pMarketValueIter + facet_wrap(~ year)
}

print(pMarketValueIter)
```

### Price duration curves

```{r price duration curves, warning = FALSE}
if (FALSE){
dataHourlyElecPricesPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "hourly_prices.csv")) %>%
  filter(carrier == "AC") %>%
  select(!carrier) %>%
  pivot_longer(cols = -c("year", "region", "carrier", "iteration"),
               names_to = "time",
               values_to = "value") %>%
  group_by(year, region, carrier, iteration) %>%
  mutate(hour = 1:n()) %>%
  arrange(-value) %>%
  mutate(hour.sorted = 1:n(),
         year.fraction = hour.sorted / n())

for (i in pyIterations) {
  dataHourlyElecPricesPyPSAplot <- dataHourlyElecPricesPyPSA %>%
    filter(iteration == i)

  pPriceDuration <- ggplot() +
    geom_line(data = dataHourlyElecPricesPyPSAplot,
              mapping = aes(x = year.fraction, y = value, color = region)) +
    labs(x = "Hours of year (fraction)", y = "Electricity price ($/MWh)") +
    ggtitle(paste("Price duration curve, iteration", i)) +
    scale_y_continuous(trans = "log10") +
    facet_wrap(~ year)

  print(pPriceDuration)
}
}
```

### Screening curves

### Inverse screening curves

### Residual load duration curves (RLDCs)

### Storage and transmission not implemented in REMIND

#### Pumped hydro storage (PHS)

# Other plots

## Runtime

```{r runtime}
# Extract iteration number from rmFiles
rmIterations <- as.numeric(gsub(".*_([0-9]+)\\.gdx", "\\1", rmFiles))
ctime <- file.info(rmFiles)$ctime

# From string in variable "scenario" extract the time stamp with format YYYY-MM-DD_HH.MM.SS
timeStamp <- gsub(".*_([0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}\\.[0-9]{2}\\.[0-9]{2})", "\\1", scenario)
timeStamp <- ymd_hms(timeStamp, tz = Sys.timezone())

runtimeTotal <- tibble(file = rmFiles, iter = rmIterations, ctime) %>%
  add_row(file = "NA", iter = 0, ctime = timeStamp) %>%
  arrange(iter) %>%
  mutate(total = ctime - lag(ctime)) %>%
  select(-file, -ctime)

# Extract iteration number from rm2pyFiles
rm2pyIterations <- as.numeric(gsub(".*_([0-9]+)\\.gdx", "\\1", rm2pyFiles))
ctime.rm2py <- file.info(rm2pyFiles)$ctime

runtimePyStart <- tibble(file = rm2pyFiles, iter = rm2pyIterations, start = ctime.rm2py) %>%
  arrange(iter) %>%
  select(-file)

# Extract iteration number from py2rmFiles
py2rmIterations <- as.numeric(gsub(".*_([0-9]+)\\.gdx", "\\1", py2rmFiles))
ctime.py2rm <- file.info(py2rmFiles)$ctime

runtimePyEnd <- tibble(file = py2rmFiles, iter = py2rmIterations, end = ctime.py2rm) %>%
  arrange(iter) %>%
  select(-file)

# Combine and calculate runtime
runtimePyPSA <- runtimePyStart %>%
  left_join(runtimePyEnd, by = "iter") %>%
  mutate(PyPSA = end - start) %>%
  select(-start, -end)

runtime <- full_join(runtimeTotal, runtimePyPSA, by = "iter") %>%
  mutate(REMIND = total - PyPSA) %>%
  select(-total) %>%
  pivot_longer(cols = c("REMIND", "PyPSA"), names_to = "model", values_to = "time")

p <- ggplot() +
  geom_col(data = runtime, aes(x = iter, y = time, fill = model)) +
  scale_fill_discrete(name = "Model") +
  labs(x = "Iteration", y = "Runtime (minutes)") +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("Runtime for each iteration", "Determined by file creation time")

print(p)

```

## VRE potentials

VRE potentials are constrained in terms of generation (TWa) in REMIND and in terms of capacity (GW) in PyPSA-Eur. REMIND VRE potentials in capacity terms therefore depend on the capacity factor as well, making them non-constant.

```{r vre potentials}
# Read vm_capFac (for dispatchable technologies)
vmCapFac <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "vm_capFac",
  columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "vmCapFac"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Read vm_capDistr (for VRE technologies)
vmCapDistr <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "vm_capDistr",
  columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "rlf", "value" = "vmCapDistr"),
  colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
  restoreZeros = FALSE)

# Read pm_dataren (nur)
pmDatarenNur <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataren",
    columns = c("all_regi" = "region", "all_te" = "technology", "char" = "char", "rlf" = "rlf", "value" = "pmDatarenNur"),
    colFilter = list("region" = regions, "char" = "nur", "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-char)

# Read pm_dataren (maxprod)
pmDatarenMaxprod <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "pm_dataren",
    columns = c("all_regi" = "region", "all_te" = "technology", "char" = "char", "rlf" = "rlf", "value" = "pmDatarenMaxprod"),
    colFilter = list("region" = regions, "char" = "maxprod", "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  select(-char) %>%
  replace_na(list(pmDatarenMaxprod = 0))

# Calculate VRE potential in GW in REMIND
dataVREpotREMIND <- pmDatarenMaxprod %>%
  left_join(pmDatarenNur) %>%
  left_join(vmCapFac, relationship = "many-to-many") %>%
  group_by(region, technology, year, iteration) %>%
  # Calculate according to q_limitProd and transform TW to GW
  summarise(value = 1E3 * sum(pmDatarenMaxprod / (pmDatarenNur * vmCapFac))) %>%
  ungroup() %>%
  revalue.levels(technology = rm2genTech) %>%
  order.levels(technology = names(colorsTech))

# PyPSA-Eur
dataVREpotPyPSA <- readPyPSAcsv(paths = file.path(pyValidationDirs, "potentials.csv")) %>%
  mutate(value = value / 1e3) %>%   # Convert capacities to GW
  filter(!is.na(value),
         !is.infinite(value)) %>%
  rename(technology = carrier) %>%
revalue.levels(technology = py2genTech) %>%
  order.levels(technology = names(colorsTech))

for (r in regions) {

  dataVREpotREMINDplot <- dataVREpotREMIND %>%
    filter(region == r)

  dataVREpotPyPSAplot <- dataVREpotPyPSA %>%
    filter(region == r)

  pVREpot <- ggplot() +
    geom_line(data = dataVREpotREMINDplot,
              mapping = aes(x = year, y = value, color = technology)) +
    geom_point(data = dataVREpotPyPSAplot,
              mapping = aes(x = year, y = value, color = technology)) +
    scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
    ) +
    labs(x = "Year", y = "VRE potential (GW)") +
    ggtitle("VRE potentials", regSubtitle(r)) +
    facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech))

  print(pVREpot)
}

pVREpot <- ggplot() +
  geom_line(data = dataVREpotREMIND,
            mapping = aes(x = year, y = value, color = region)) +
  geom_point(data = dataVREpotPyPSA,
            mapping = aes(x = year, y = value, color = region)) +
  labs(x = "Year", y = "VRE potential (GW)") +
  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("VRE potential over years") +
  facet_grid(technology ~ iteration, scales = "free", labeller = labeller(technology = namesTech))

print(pVREpot)
```

## Original PyPSA-Eur costs vs. REMIND costs

# Plots for presentations

```{r plots for presentations}
if (FALSE) {
iter <- 20
theme_set(theme_cowplot(font_size = 12, line_size = 0.25))
theme_update(panel.grid.major.y = element_line(color = "grey", linewidth = 0.25),
             plot.title = element_text(hjust = 0.5, face = "plain", size = 12))

# ELECTRICITY LOAD
dataLoadREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeDispNet",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = "seel"),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  filter(iteration == iter)

# Load PyPSAEUR electricity loads for cross-checking
dataLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_loads.csv")) %>%
  mutate(value = value / 1e6) %>%  # Convert MWh to TWh
  filter(iteration == iter)

# Plot by year
pYear <- ggplot() +
  geom_line(data = dataLoadREMIND, aes(x = year, y = value, color = region)) +
  geom_point(data = dataLoadPyPSA, aes(x = year, y = value, color = region)) +
  scale_color_discrete(name = "Region") +
  labs(x = "Year", y = "Electricity load (TWh/a)") +
  scale_y_continuous(limit = c(0, NA)) +
  ggtitle("Electricity load by year")

ggsave("load.png", width = 14, height = 10, units = "cm", dpi = 300, bg = "white")

# CAPEX
dataCapexREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_capCostwAdjCost",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_capCostwAdjCost"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTW2USDpMW) %>%
  filter(iteration == iter)

# Calculated weighted average
dataCapexWeightedREMIND <- dataCapexREMIND %>%
  full_join(dataWeightREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(capex = sum(p32_capCostwAdjCost * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration == iter) %>%
  filter(technology %in% c("wind_onshore", "wind_offshore", "solar_pv")) %>%
  filter(year <= 2100)

# PyPSA-Eur
dataCapexPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "investment") %>%
  filter(iteration == iter)

# Costs directly from REMIND
dataCapexPyPSArm <- dataCapexPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(technology, parameter, source, iteration, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique_tolerance(value)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(technology %in% c("wind_onshore", "wind_offshore", "solar_pv")) %>%
  filter(year <= 2100)

# Costs passed from REMIND to PyPSA-Eur
pCapexYear <- ggplot() +
  geom_line(data = dataCapexWeightedREMIND, aes(x = year, y = capex, color = technology), show.legend = FALSE) +
  geom_point(data = dataCapexPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5, show.legend = FALSE) +
  scale_color_manual(name = "Technology\n(directly from REMIND)",
                     values = colorsTech,
                     labels = namesTech) +
  labs(x = "Year", y = "Specific capital costs (USD/kW)") +
  scale_y_continuous(labels = function(x) x / 1000, limits = c(0,NA)) +
  ggtitle("Specific capital costs (w/ adjustment costs)") +
  facet_wrap(~ technology, scales = "free", labeller = labeller(technology = namesTech))

ggsave("capex.png", width = 18, height = 8, units = "cm", dpi = 300, bg = "white")

# FUEL COSTS
# Read pe2se mapping from REMIND
pe2seTech <- gdx::readGDX(rmFiles[1], "pe2se") %>%
  rename(pecarrier = all_enty,
         secarrier = all_enty1,
         technology = all_te) %>%
  filter(secarrier == "seel") %>%
  select(pecarrier, technology)

# Read REMIND data (averaged)
dataFuelCostsAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PEPriceAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "pecarrier", "value" = "p32_PEPriceAvg"),
    colFilter = list("year" = years, "region" = regions)) %>%
  full_join(pe2seTech, by = c("pecarrier"), relationship = "many-to-many") %>%
  full_join(dataEtaConvREMIND) %>%
  # Special treatment for nuclear: Costs in T$/Mt_U = $/gU -> don't convert
  mutate(p32_PEPriceAvg = case_when(pecarrier == "peur" ~ p32_PEPriceAvg,
                                    pecarrier != "peur" ~ p32_PEPriceAvg * trUSDpTWa2USDpMWh))

# Calculate weighted average fuel costs
dataFuelCostsAvgWeightedREMIND <- dataFuelCostsAvgREMIND %>%
  right_join(dataWeightGenREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, technology, iteration) %>%
  summarise(fuelCost = sum(p32_PEPriceAvg * weight) / sum(weight)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration %in% pyIterations)

# Remove technologies for which fuel costs are always zero in REMIND
zeroTech <- dataFuelCostsAvgWeightedREMIND %>%
  group_by(technology) %>%
  filter(all(fuelCost == 0)) %>%
  pull(technology) %>%
  unique()

dataFuelCostsAvgWeightedREMIND <- dataFuelCostsAvgWeightedREMIND %>%
  filter(!(technology %in% zeroTech)) %>%
  filter(iteration == iter) %>%
  filter(year <= 2100)

# Read PyPSA-Eur data
dataFuelCostsPyPSA <- readPyPSAcsv(
  paths = file.path(pyResourcesDirs, "costs.csv")) %>%
  filter(parameter == "fuel")

# For gas create two technologies: CCGT and OCGT
dataFuelCostsPyPSA <- dataFuelCostsPyPSA %>%
  filter(technology != "gas") %>%
  bind_rows(
    filter(dataFuelCostsPyPSA, technology == "gas") %>%
      mutate(technology = "CCGT"),
    filter(dataFuelCostsPyPSA, technology == "gas") %>%
      mutate(technology = "OCGT")
  )

# Fuel costs directly from REMIND
dataFuelCostsPyPSArm <- dataFuelCostsPyPSA %>%
  filter(source == "REMIND-EU") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(technology, parameter, source, iteration, year) %>%
  # Values should be the same across generic technologies
  summarise(value = unique(value)) %>%
  order.levels(technology = names(colorsTech)) %>%
  filter(iteration == iter) %>%
  filter(year <= 2100)

pFuelCostsYear <- ggplot() +
  geom_line(data = dataFuelCostsAvgWeightedREMIND, aes(x = year, y = fuelCost, color = technology)) +
  geom_point(data = dataFuelCostsPyPSArm, aes(x = year, y = value, color = technology), alpha = 0.5) +
  scale_color_manual(name = "Technology",
                     values = colorsTech,
                     labels = namesTech) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(x = "Year", y = "Fuel costs (USD/MWh)") +
  ggtitle("Fuel costs")

ggsave("fuel_costs.png", width = 14, height = 8, units = "cm", dpi = 300, bg = "white")

# MARKET VALUES
dataMarkupREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_PyPSAMarkup",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = trUSDpTWa2USDpMWh)

dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_enty" = "secarrier", "all_te" = "technology", "value" = "v32_usableSeTeDisp"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%
  select(-secarrier)

dataMarkupWeightedREMIND <- dataMarkupREMIND %>%
  right_join(dataGenREMIND, by = c("year", "region", "technology", "iteration")) %>%
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value * v32_usableSeTeDisp) / sum(v32_usableSeTeDisp)) %>%
  order.levels(technology = names(namesTech)) %>%
  filter(iteration == iter)

pMarkupYear <- ggplot() +
  geom_line(data = dataMarkupWeightedREMIND, aes(x = year, y = value, color = technology)) +
  geom_point(data = dataMarkupWeightedREMIND, aes(x = year, y = value, color = technology)) +
  scale_color_manual(
      name = "Technology",
      values = colorsTech,
      labels = namesTech,
  ) +
  scale_x_continuous(limits = c(2025,2100), breaks = c(2025,2040,2060,2080,2100)) +
  labs(x = NULL, y = "Markup ($/MWh)") +
  ggtitle("Markups by technology, Germany")

ggsave("markup_year.png", width = 16, height = 10, units = "cm", dpi = 300, bg = "white")

# CAPACITY FACTORS
dataCapFacAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PyPSA_CFAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PyPSA_CFAvg"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  # Increment iteration by 1 because this value is only available for the next iteration
  group_by(year, region, technology, iteration) %>%
  summarise(p32_PyPSA_CFAvg = unique(p32_PyPSA_CFAvg)) %>%
  filter(iteration == iter) %>%
  revalue.levels(technology = rm2genTech)

pCapfacYear <- ggplot() +
  geom_line(data = dataCapFacAvgREMIND, aes(x = year, y = p32_PyPSA_CFAvg, color = technology)) +
  geom_point(data = dataCapFacAvgREMIND, aes(x = year, y = p32_PyPSA_CFAvg, color = technology)) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
    breaks = names(namesTech)
  ) +
  scale_x_continuous(limits = c(2025,2100), breaks = c(2025,2040,2060,2080,2100)) +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = NULL, y = "Capacity factor") +
  ggtitle("Capacity factors, Germany")

ggsave("capfac_year_new.png", width = 16, height = 10, units = "cm", dpi = 300, bg = "white")

# CAPACITY FACTORS OVER ITERATIONS IN 2025/2030
dataCapFacAvgREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "p32_PyPSA_CFAvg",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "p32_PyPSA_CFAvg"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(p32_PyPSA_CFAvg = unique(p32_PyPSA_CFAvg)) %>%
  revalue.levels(technology = rm2genTech) %>%
  filter(year %in% c(2025,2030))

dataCapfacPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "capacity_factors.csv")) %>%
  # Increment iteration by 1 to match REMIND
  mutate(iteration = iteration + 1) %>%
  quitte::revalue.levels(carrier = rm2genTech) %>%
  group_by(year, region, carrier, iteration) %>%
  summarise(value = unique(value)) %>%
  filter(year %in% c(2025,2030)) %>%
  rename(technology = carrier)

pCapfacIter <- ggplot() +
  geom_line(data = dataCapFacAvgREMIND, aes(x = iteration, y = p32_PyPSA_CFAvg, color = technology)) +
  geom_point(data = dataCapFacAvgREMIND, aes(x = iteration, y = p32_PyPSA_CFAvg, color = technology)) +
  #geom_point(data = dataCapfacPyPSA, aes(x = iteration, y = value, color = technology), shape = 4) +
  scale_color_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech,
    breaks = names(namesTech)
  ) +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Iteration", y = "Capacity factor") +
  ggtitle("Capacity factors, Germany") +
  facet_wrap(~year)

ggsave("capfac_iter.png", width = 22, height = 10, units = "cm", dpi = 300, bg = "white")

# PEAK RESIDUAL LOAD
dataPeakResLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "peak_residual_loads.csv")) %>%
  filter(iteration == iter)

pPeakResLoadAbsYear <- ggplot() +
  geom_line(data = dataPeakResLoadPyPSA, aes(x = year, y = absolute, color = region)) +
  geom_point(data = dataPeakResLoadPyPSA, aes(x = year, y = absolute, color = region)) +
  labs(x = NULL, y = "Peak residual load (GW)") +
  scale_color_discrete(name = "Region", labels = c("DEU" = "Germany")) +
  scale_x_continuous(limits = c(2025,2100), breaks = c(2025,2040,2060,2080,2100)) +
  scale_y_continuous(labels = function(x) x / 1000, limits = c(0,NA)) +
  ggtitle("Peak residual load")

ggsave("peakresload_year_new.png", width = 16, height = 10, units = "cm", dpi = 300, bg = "white")

# CAPACITY
dataCapREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "vm_cap",
    columns = c("tall" = "year", "all_regi" = "region", "all_te" = "technology", "rlf" = "grade", "value" = "vm_cap"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech), "grade" = 1),
    restoreZeros = FALSE,
    recalcUnit = 1e3) %>%   # TW to GW
  select(-grade)  # Remove grade column

dataCapREMINDplot <- dataCapREMIND %>%
  revalue.levels(technology = rm2genTech) %>%
  filter(technology != "electrolysis") %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(vm_cap)) %>%
  order.levels(technology = names(colorsTech))

# Calculate minimum required capacities in REMIND from peak residual load in PyPSA-Eur
dataGenREMIND <- readREMINDgdx(
  paths = rmFiles,
  gdxVar = "v32_usableSeDispNet",
  columns = c("ttot" = "year", "all_regi" = "region", "value" = "v32_usableSeDispNet"),
  colFilter = list("year" = years, "region" = regions),
  restoreZeros = FALSE,
  recalcUnit = 1E3)  # TWa to GWa

dataPeakResLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "peak_residual_loads.csv")) %>%
  mutate(absolute = absolute / 1e3)  # Convert capacities to GW

dataPeakResLoadMinREMIND <- full_join(dataPeakResLoadPyPSA %>% mutate(iteration = iteration + 1),
                                      dataGenREMIND) %>%
  mutate(minCap = relative * v32_usableSeDispNet)

# Read optimal capacities from the CSV files
dataCapPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "optimal_capacities.csv")) %>%
  rename(technology = carrier) %>%
  mutate(value = value / 1e3) %>%  # Convert capacities to GW
  filter(!is.na(value),
         technology != "Load shedding")

dataCapPyPSAplot <- dataCapPyPSA %>%
  filter(type == "Generator") %>%
  revalue.levels(technology = py2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

r <- "DEU"
i <- iter

dataCapREMINDploti <- dataCapREMINDplot %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year, technology) %>%
  summarise(value = sum(value))

dataCapREMINDplotitot <- dataCapREMINDploti %>%
  group_by(year) %>%
  summarise(value = sum(value))

dataCapPyPSAploti <- dataCapPyPSAplot %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year, technology) %>%
  summarise(value = sum(value))

dataCapPyPSAplotitot <- dataCapPyPSAploti %>%
  group_by(year) %>%
  summarise(value = sum(value))

dataPeakResLoadMinREMINDplot <- dataPeakResLoadMinREMIND %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year) %>%
  summarise(minCap = sum(minCap))

dataPeakResLoadPyPSAplot <- dataPeakResLoadPyPSA %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year) %>%
  summarise(minCap = sum(absolute))

pCapComp <- ggplot() +
  geom_bar(data = dataCapREMINDploti,
          mapping = aes(x = year, y = value, fill = technology),
          stat = "identity",
          position = position_stacknudge(x = -1),
          width = 1.7) +
  geom_bar(data = dataCapREMINDplotitot,
          mapping = aes(x = year, y = value, linetype = "REMIND"),
          stat = "identity",
          position = position_nudge(x = -1),
          width = 1.7,
          linewidth = 0.25,
          color = "black",
          fill = NA) +
  geom_bar(data = dataCapPyPSAploti,
          mapping = aes(x = year, y = value, fill = technology),
          stat = "identity",
          position = position_stacknudge(x = 1),
          width = 1.7) +
  geom_bar(data = dataCapPyPSAplotitot,
          mapping = aes(x = year, y = value, linetype = "PyPSA-Eur"),
          stat = "identity",
          position = position_nudge(x = 1),
          width = 1.7,
          linewidth = 0.25,
          color = "black",
          fill = NA) +
  geom_point(data = dataPeakResLoadMinREMINDplot,
            mapping = aes(x = year, y = minCap, shape = "Peak residual load"),
            position = position_nudge(x = -1),
            fill = "white") +
  geom_point(data = dataPeakResLoadPyPSAplot,
            mapping = aes(x = year, y = minCap, shape = "Peak residual load"),
            position = position_nudge(x = 1),
            fill = "white") +
  scale_fill_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech
    ) +
  scale_linetype_manual(
    name = "Model",
    values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
  ) +
  scale_shape_manual(
    name = NULL,
    values = c("Peak residual load" = 23),
  ) +
  scale_x_continuous(limits = c(2022,2103), breaks = years) +
  labs(x = NULL, y = "Capacity (GW)") +
  ggtitle("Optimal capacity, Germany")

ggsave("capcomp_year_new.png", width = 30, height = 14, units = "cm", dpi = 300, bg = "white")

# GENERATION
dataGenREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeTeDisp",
    columns = c("ttot" = "year", "all_regi" = "region", "all_te" = "technology", "value" = "value"),
    colFilter = list("year" = years, "region" = regions, "technology" = names(rm2genTech)),
    restoreZeros = FALSE,
    recalcUnit = twa2twh) %>%  # TWa to TWh
  revalue.levels(technology = rm2genTech) %>%
  group_by(year, region, technology, iteration) %>%
  summarise(value = sum(value)) %>%
  order.levels(technology = names(colorsTech))

# REMIND load in total
dataLoadREMIND <- readREMINDgdx(
    paths = rmFiles,
    gdxVar = "v32_usableSeDispNet",
    columns = c("ttot" = "year", "all_regi" = "region", "value" = "value"),
    colFilter = list("year" = years, "region" = regions),
    restoreZeros = FALSE,
    recalcUnit = twa2twh)

# PyPSA-Eur generation by technology
dataGenPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "generations.csv")) %>%
  mutate(value = value / 1e6) %>%  # MWh to TWh
  rename(technology = carrier) %>%
  revalue.levels(technology = py2genTech) %>%
  order.levels(technology = names(colorsTech))

# PyPSA-Eur load in total
dataLoadPyPSA <- readPyPSAcsv(
  paths = file.path(pyValidationDirs, "electricity_loads.csv")) %>%
  mutate(value = value / 1e6)  # Convert MWh to TWh

r <- "DEU"
i <- iter

dataGenREMINDploti <- dataGenREMIND %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year, technology) %>%
  summarise(value = sum(value))

dataGenREMINDplotitot <- dataGenREMINDploti %>%
  group_by(year) %>%
  summarise(value = sum(value))

dataLoadREMINDploti <- dataLoadREMIND %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year) %>%
  summarise(value = sum(value))

dataGenPyPSAploti <- dataGenPyPSA %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year, technology) %>%
  summarise(value = sum(value))

dataGenPyPSAplotitot <- dataGenPyPSAploti %>%
  group_by(year) %>%
  summarise(value = sum(value))

dataLoadPyPSAploti <- dataLoadPyPSA %>%
  filter(region %in% r,
          iteration == i) %>%
  group_by(year) %>%
  summarise(value = sum(value))

pGenComp <- ggplot() +
  geom_bar(data = dataGenREMINDploti,
          mapping = aes(x = year, y = value, fill = technology),
          stat = "identity",
          position = position_stacknudge(x = -1),
          width = 1.7) +
  geom_bar(data = dataGenREMINDplotitot,
          mapping = aes(x = year, y = value, linetype = "REMIND"),
          stat = "identity",
          position = position_nudge(x = -1),
          width = 1.7,
          linewidth = 0.25,
          color = "black",
          fill = NA) +
  geom_point(data = dataLoadREMINDploti,
              mapping = aes(x = year, y = value, color = "Load"),
              position = position_nudge(x = -1),
              shape = 4) +
  geom_bar(data = dataGenPyPSAploti,
          mapping = aes(x = year, y = value, fill = technology),
          stat = "identity",
          position = position_stacknudge(x = 1),
          width = 1.7) +
  geom_bar(data = dataGenPyPSAplotitot,
          mapping = aes(x = year, y = value, linetype = "PyPSA-Eur"),
          stat = "identity",
          position = position_nudge(x = 1),
          width = 1.7,
          linewidth = 0.25,
          color = "black",
          fill = NA) +
  geom_point(data = dataLoadPyPSAploti,
              mapping = aes(x = year, y = value, color = "Load"),
              position = position_nudge(x = 1),
              shape = 4) +
  scale_fill_manual(
    name = "Technology",
    values = colorsTech,
    labels = namesTech) +
  scale_linetype_manual(
    name = "Model",
    values = c("REMIND" = "solid", "PyPSA-Eur" = "dashed"),
  ) +
  scale_color_manual(
    name = NULL,
    values = c("Load" = "black"),
  ) +
  scale_x_continuous(limits = c(2022,2103), breaks = years) +
  labs(x = NULL, y = "Generation (TWh)") +
  ggtitle("Optimal generation, Germany")

ggsave("gencomp_year_new.png", width = 30, height = 14, units = "cm", dpi = 300, bg = "white")
}
```